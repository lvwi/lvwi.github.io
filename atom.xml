<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lvv&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lvwi.github.io/"/>
  <updated>2021-05-31T03:04:42.698Z</updated>
  <id>http://lvwi.github.io/</id>
  
  <author>
    <name>lvv</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java项目部署</title>
    <link href="http://lvwi.github.io/2021/05/31/java%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <id>http://lvwi.github.io/2021/05/31/java%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</id>
    <published>2021-05-31T02:40:40.000Z</published>
    <updated>2021-05-31T03:04:42.698Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>java项目部署</p><a id="more"></a></blockquote><p>##部署步骤</p><h3 id="打包maven项目"><a href="#打包maven项目" class="headerlink" title="打包maven项目"></a>打包maven项目</h3><blockquote><p>在idea的terminal中输入命令:<br><code>mvn clean package</code><br>mvn clean 是打包前清理掉之前有打包的文件夹target<br>mvn package 项目打包,包括了编译\打包两步<br>命令执行完成后,会自动生成target文件, 并且出现BUILD SUCCESS 字样</p></blockquote><h3 id="jar包部署"><a href="#jar包部署" class="headerlink" title="jar包部署"></a>jar包部署</h3><blockquote><p>在控制台输入命令: <code>java -jar test.jar</code><br>在命令中添加-d ,如<code>java -Dfile.encoding=UTF-8 -jar app.jar --nacos.config.server-addr=nacos.test:8848</code>, 可以修改配置文件内容, nacos是注册中心,用来存放信息</p></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;java项目部署&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端设计</title>
    <link href="http://lvwi.github.io/2021/05/26/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/"/>
    <id>http://lvwi.github.io/2021/05/26/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-05-26T07:13:57.000Z</published>
    <updated>2021-05-31T03:07:00.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>前端设计</p><a id="more"></a></blockquote><h2 id="png格式文件转为icon的方法"><a href="#png格式文件转为icon的方法" class="headerlink" title="png格式文件转为icon的方法"></a>png格式文件转为icon的方法</h2><h2 id="layui学习"><a href="#layui学习" class="headerlink" title="layui学习"></a>layui学习</h2><h2 id="css文件中获取class属性"><a href="#css文件中获取class属性" class="headerlink" title="css文件中获取class属性"></a>css文件中获取class属性</h2><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;前端设计&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>操作系统的学习</title>
    <link href="http://lvwi.github.io/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-05-17T07:19:36.000Z</published>
    <updated>2021-05-17T07:32:45.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>首页显示摘要内容（替换成自己的）</p><a id="more"></a></blockquote><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>操作系统—与硬件打交道,  把操作硬件的代码形成系统调用, 供其他软件使用</p><h1 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h1><blockquote><h2 id="桌面操作系统"><a href="#桌面操作系统" class="headerlink" title="桌面操作系统"></a>桌面操作系统</h2><blockquote><p>window系列 : 用户群体大</p><p>macos: 适合开发人员</p><p>Linux: 应用软件少</p></blockquote><h2 id="服务器操作系统"><a href="#服务器操作系统" class="headerlink" title="服务器操作系统"></a>服务器操作系统</h2><blockquote><p>Linux: 安全/稳定/免费</p><p>windows Server:付费/占用率低</p></blockquote><h2 id="嵌入式操作系统-linux"><a href="#嵌入式操作系统-linux" class="headerlink" title="嵌入式操作系统:linux"></a>嵌入式操作系统:linux</h2><h2 id="移动设备操作系统-ios-Android-基于linux"><a href="#移动设备操作系统-ios-Android-基于linux" class="headerlink" title="移动设备操作系统 : ios, Android(基于linux)"></a>移动设备操作系统 : ios, Android(基于linux)</h2></blockquote><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>通过软件模拟具有完整硬件系统功能的,运行在一个完全隔离环境中的完整计算机系统</p><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;首页显示摘要内容（替换成自己的）&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>numpy学习</title>
    <link href="http://lvwi.github.io/2021/04/30/numpy%E5%AD%A6%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2021/04/30/numpy%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-04-30T03:06:50.000Z</published>
    <updated>2021-04-30T03:43:09.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>numpy学习</p><a id="more"></a></blockquote><h1 id="numpy是什么"><a href="#numpy是什么" class="headerlink" title="numpy是什么"></a>numpy是什么</h1><p>是python的科学计算基础库，用于大多数计算</p><h1 id="numpy的使用"><a href="#numpy的使用" class="headerlink" title="numpy的使用"></a>numpy的使用</h1><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>import numpy as np</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>numpy生成数组</td><td>t1 = np.array([1,2,3,4,5,])  ;  np.array(range(1,6)) ; np.arrange(1,6,[1], dtype = ??)</td></tr><tr><td>获取数据类型</td><td>t1.dtype</td></tr><tr><td>调整数组数据类型</td><td>t1.astype( “int8 “ ) 修改类型为 int8</td></tr><tr><td>保留小数位数</td><td>np.round(t1, 2)   t1数组的小数保留2位</td></tr><tr><td>数组的形状</td><td>t1.shape —-&gt; (5 , )    几行几列</td></tr><tr><td>修改数组的形状</td><td>t1.reshape((3,4))  变为3行4列   这种情况只能在12个数据或者成倍的情况下 ;   1个值表示1维, 2个数表示2维  ;;</td></tr><tr><td></td><td>t1.flatten()   将数据展开为1维的</td></tr><tr><td></td><td></td></tr></tbody></table><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;numpy学习&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python的matplotlib模块学习</title>
    <link href="http://lvwi.github.io/2021/04/12/python%E7%9A%84matplotlib%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2021/04/12/python%E7%9A%84matplotlib%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-04-12T08:36:04.000Z</published>
    <updated>2021-04-13T09:14:11.900Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要: mat-plot-lib模块</p></blockquote><h2 id="python的mat-plot-lib模块"><a href="#python的mat-plot-lib模块" class="headerlink" title="python的mat-plot-lib模块"></a>python的mat-plot-lib模块</h2><h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> import matplotlib.pyplot as plt</span><br><span class="line">&gt;import matplotlib.font_manager as  fm</span><br><span class="line"># plt.plot([1,3,5],[4, 6, 8])</span><br><span class="line"># plt.show()</span><br><span class="line">import numpy as np</span><br><span class="line"># x &#x3D; np.linspace(-np.pi,np.pi,100)</span><br><span class="line"># plt.plot(x,np.sin(x))</span><br><span class="line"># plt.show()</span><br><span class="line"># 20210412</span><br><span class="line"># plt复习</span><br><span class="line">x &#x3D; range(2,26,2)</span><br><span class="line">y &#x3D; [10,23,5,66,33,44,12,43,57,11,34,12]</span><br><span class="line">y2 &#x3D; [10,44,12,57,11,34,43,12,23,5,66,33]</span><br><span class="line"># 修改图片大小和分辨率</span><br><span class="line">plt.figure(figsize&#x3D;(20,8),dpi&#x3D;80)</span><br><span class="line"># 修改轴刻度</span><br><span class="line">plt.xticks(x[::2])</span><br><span class="line"># 修改轴刻度为中文 , 第2个参数一定要用 [ ]   # 中文显示: 先导入font_manager模块,然后引用系统中的中文字体信息, 最后在用的地方引用自己的字体fontproperties &#x3D; zwfont</span><br><span class="line"># 刻度方向调整: 刻度过长的话, 会重合, 可以切换角度 rotation&#x3D;角度</span><br><span class="line">zwfont &#x3D; fm.FontProperties(fname&#x3D;&quot;C:\Windows\Fonts\msyh.ttc&quot;)</span><br><span class="line">plt.xticks(x, [&quot;4月1号&#123;&#125;点&quot;.format(i)for i in range(2, 26, 2)], fontproperties&#x3D;zwfont, rotation&#x3D;45)</span><br><span class="line"># 轴标签说明, 标题说明</span><br><span class="line">plt.xlabel(&quot;时间&quot;, fontproperties&#x3D;zwfont)</span><br><span class="line">plt.ylabel(&quot;个数&quot;, fontproperties&#x3D;zwfont)</span><br><span class="line">plt.title(&quot;数据展示&quot;, fontproperties&#x3D;zwfont)</span><br><span class="line"># 绘制网格, 网格透明度  alpha &#x3D; 0.4, 网格的绘制是根据刻度来体现的, 要调整网格线的多少, 修改刻度</span><br><span class="line">plt.grid(alpha &#x3D; 0.4)</span><br><span class="line"></span><br><span class="line"># 折线的形状,颜色等:  color&#x3D;&#39;green&#39;, marker&#x3D;&#39;o&#39;, linestyle&#x3D;&#39;dashed&#39;,linewidth&#x3D;2, markersize&#x3D;12</span><br><span class="line"># 图例说明折线代表信息 label&#x3D;&quot;同学1&quot;</span><br><span class="line">plt.plot(x, y, color&#x3D;&#39;green&#39;, marker&#x3D;&#39;o&#39;, linestyle&#x3D;&#39;dashed&#39;,linewidth&#x3D;2, markersize&#x3D;12, label&#x3D;&quot;同学1&quot;)</span><br><span class="line"># 一个图形中绘制多个图形,多绘制一次即可</span><br><span class="line">plt.plot(x, y2, label&#x3D;&quot;同学2&quot;)</span><br><span class="line"># 保存的时候有报错: Invalid argument: &#39;\u202aC:&#x2F;Users&#x2F;vivid&#x2F;Desktop&#x2F;11.jpg&#39;</span><br><span class="line"># 原因: 地址是复制过来的, 有不显示的符号, 手动输入即可</span><br><span class="line"># plt.savefig(&quot;C:&#x2F;Users&#x2F;vivid&#x2F;Desktop&#x2F;11.jpg&quot;)</span><br><span class="line"># 图例所在位置,图例的文字格式比较特使,属性用prop &#x3D; zwfont</span><br><span class="line">plt.legend(loc&#x3D;1,prop &#x3D; zwfont)</span><br><span class="line"># 图形标记</span><br><span class="line"># 添加水印</span><br><span class="line"># 图片保存</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></blockquote><h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, label=<span class="string">"6月份气温"</span>)</span><br></pre></td></tr></table></figure><p>其他的语句与plot没有区别</p><h4 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h4><h5 id="方法bar"><a href="#方法bar" class="headerlink" title="方法bar()"></a>方法bar()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zw_font &#x3D; fm.FontProperties(fname&#x3D;&quot;C:&#x2F;Windows&#x2F;Fonts&#x2F;msyh.ttc&quot;)</span><br><span class="line"></span><br><span class="line">sx &#x3D; &quot;战狼2 哪吒之魔童降世 流浪地球 复仇者联盟4：终局之战 红海行动&quot;</span><br><span class="line">x &#x3D; sx.split(&quot; &quot;)</span><br><span class="line">sy &#x3D; &quot;56.39 49.34 46.18 42.05 36.22&quot;</span><br><span class="line"># y &#x3D;sy.split(&quot; &quot;)</span><br><span class="line">y &#x3D; [56.39, 49.34, 46.18, 42.05, 36.22]</span><br><span class="line"># print(type(sy.split(&quot; &quot;)))</span><br><span class="line"># print(type(y))</span><br><span class="line">plt.bar(range(len(x)), y)</span><br><span class="line">plt.xticks(range(len(x)),x, fontproperties&#x3D;zw_font)</span><br><span class="line">plt.title(&quot;电影票房&quot;,fontproperties&#x3D;zw_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h5 id="方法barh"><a href="#方法barh" class="headerlink" title="方法barh()"></a>方法barh()</h5><p>但是存在问题, 若x轴的文字描述较长, 会出现信息对不齐,部分缺失的问题</p><p>这时候可以用barh , 横向条形图</p><p>注意: 这里plt.barh(range(len(x)),y,height=0.8)的x , y不用换位置</p><p>​        bar与barh 不同的参数: bar 是width , barh 是height=0.8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zw_font &#x3D; fm.FontProperties(fname&#x3D;&quot;C:&#x2F;Windows&#x2F;Fonts&#x2F;msyh.ttc&quot;)</span><br><span class="line"></span><br><span class="line">sx &#x3D; &quot;战狼2 哪吒之魔童降世 流浪地球 复仇者联盟4：终局之战 红海行动&quot;</span><br><span class="line">x &#x3D; sx.split(&quot; &quot;)</span><br><span class="line">sy &#x3D; &quot;56.39 49.34 46.18 42.05 36.22&quot;</span><br><span class="line"># y &#x3D;sy.split(&quot; &quot;)</span><br><span class="line">y &#x3D; [56.39, 49.34, 46.18, 42.05, 36.22]</span><br><span class="line"># print(type(sy.split(&quot; &quot;)))</span><br><span class="line"># print(type(y))</span><br><span class="line">plt.barh(range(len(x)),y,height&#x3D;0.8)</span><br><span class="line">plt.yticks(range(len(x)),x, fontproperties&#x3D;zw_font)</span><br><span class="line">plt.title(&quot;电影票房&quot;,fontproperties&#x3D;zw_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h5 id="绘制多个条形图"><a href="#绘制多个条形图" class="headerlink" title="绘制多个条形图"></a>绘制多个条形图</h5><p>因同一个x轴上要绘制多个条形图, 故条形图的宽度需要设置下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sx = <span class="string">"战狼2 哪吒之魔童降世 流浪地球 复仇者联盟4：终局之战 红海行动"</span></span><br><span class="line">x = sx.split(<span class="string">" "</span>)</span><br><span class="line">sy = <span class="string">"56.39 49.34 46.18 42.05 36.22"</span></span><br><span class="line"><span class="comment"># y =sy.split(" ")</span></span><br><span class="line">bar_with = <span class="number">0.3</span></span><br><span class="line">x_14 = range(len(x))</span><br><span class="line">x_15 = [i+ bar_with <span class="keyword">for</span> i <span class="keyword">in</span> x_14]</span><br><span class="line">x_16 = [i + bar_with*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> x_14]</span><br><span class="line">y_14 = [<span class="number">15768</span>,<span class="number">213</span>,<span class="number">2253</span>, <span class="number">2353</span>,<span class="number">1235</span>]</span><br><span class="line">y_15 = [<span class="number">12334</span>,<span class="number">456</span>,<span class="number">5643</span>, <span class="number">12563</span>,<span class="number">24454</span>]</span><br><span class="line">y_16 = [<span class="number">3433</span>,<span class="number">789</span>,<span class="number">3456</span>, <span class="number">24565</span>,<span class="number">9456</span>]</span><br><span class="line"><span class="comment"># print(type(sy.split(" ")))</span></span><br><span class="line"><span class="comment"># print(type(y))</span></span><br><span class="line">plt.bar(x_14,y_14, width=bar_with)</span><br><span class="line">plt.bar(x_15,y_15,width=bar_with)</span><br><span class="line">plt.bar(x_16,y_16,width=bar_with)</span><br><span class="line">plt.xticks(x_15,x, fontproperties=zw_font)</span><br><span class="line">plt.title(<span class="string">"电影票房"</span>,fontproperties=zw_font)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>碰到的问题</p><p><a href="https://blog.csdn.net/qq_41997122/article/details/115668022" target="_blank" rel="noopener">y轴刻度显示不正常</a></p><p><a href="https://blog.csdn.net/qq_41997122/article/details/115660509?spm=1001.2014.3001.5501" target="_blank" rel="noopener">执行plt.bar语句报错</a></p><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="number">1</span>,<span class="number">21</span>)</span><br><span class="line">y = sy.split(<span class="string">" "</span>)</span><br><span class="line">y1 = [<span class="number">25</span>, <span class="number">4</span>, <span class="number">13</span> , <span class="number">12</span>, <span class="number">43</span>, <span class="number">15</span>, <span class="number">17</span> , <span class="number">10</span> , <span class="number">4</span> , <span class="number">42</span> , <span class="number">14</span> ,<span class="number">11</span> ,<span class="number">5</span>  ,<span class="number">27</span>, <span class="number">10</span> , <span class="number">19</span> , <span class="number">18</span> , <span class="number">8</span> , <span class="number">23</span> , <span class="number">49</span>]</span><br><span class="line"><span class="comment"># 计算组距</span></span><br><span class="line">d = <span class="number">2</span></span><br><span class="line"><span class="comment"># 计算组数</span></span><br><span class="line">num = (max(y1*<span class="number">10</span>) - min(y1*<span class="number">10</span>))/<span class="number">2</span></span><br><span class="line">print(int(num))</span><br><span class="line"></span><br><span class="line"><span class="comment"># hist方法中参数1： 数据源，参数2： 20 代表分为几组 参数2: normed= True 显示的是比率, 不写,默认显示的是频数</span></span><br><span class="line"><span class="comment"># normed= True 现在库已经更新,没有了, 可以用density=1 ,stacked=True替代</span></span><br><span class="line">plt.hist(y1, int(num), density=<span class="number">1</span>,stacked=<span class="literal">True</span>)</span><br><span class="line">plt.xticks(range(min(y1*<span class="number">10</span>),max(y1*<span class="number">10</span>)+d, d))</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘要: mat-plot-lib模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;python的mat-plot-lib模块&quot;&gt;&lt;a href=&quot;#python的mat-plot-lib模块&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>pythonAndExcle</title>
    <link href="http://lvwi.github.io/2021/04/07/pandas%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2021/04/07/pandas%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-04-07T06:13:18.000Z</published>
    <updated>2021-04-09T09:12:17.719Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要: pandas </p></blockquote><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p>pandas 是基于NumPy的一种工具，支持xls与xlsx文件格式。该工具是为了解决数据分析任务而创建的<br>NaN（不是数字）是大熊猫中使用的标准缺失数据标记。</p><h2 id="基础数据"><a href="#基础数据" class="headerlink" title="* 基础数据"></a>* 基础数据</h2><h3 id="一-Series-一维数组"><a href="#一-Series-一维数组" class="headerlink" title="一. Series 一维数组"></a>一. Series 一维数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; pd.Series(参数: 列表[1,2,3,4], index(索引)&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;f&#39;], name&#x3D;&quot;series的名称属性&quot;)</span><br><span class="line">s &#x3D; pd.Series(参数: 字典&#123;&#39;a&#39;:3,&#39;b&#39;:4,&#39;c&#39;:5,&#39;f&#39;:6,&#39;e&#39;:8&#125;)</span><br><span class="line">s &#x3D; pd.Series(参数: 标量值 5, index&#x3D;[1,2,3,4]) 5会重复对应index来显示</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="1-取值"><a href="#1-取值" class="headerlink" title="1. 取值"></a>1. 取值</h5><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>s[index] ,s[ [index的list] ]</td><td>取值操作类似数组，当取不连续的多个值时可以以一list为参数</td></tr><tr><td>s.head(n)</td><td>取头n行, n不填默认为0</td></tr><tr><td>s.tail(n)</td><td>取尾n行, n不填默认为0</td></tr><tr><td>s.index</td><td>取出index,返回list</td></tr><tr><td>s.values</td><td>取出values ,返回list, 不建议使用这个方法</td></tr><tr><td>s.get(1或者”a” , xx)</td><td>取数索引为1或者”a”对应的值, 缺少标签将返回None或指定默认值xx, xx可省略</td></tr><tr><td>s.unique()</td><td>取出 出现不重复values值</td></tr><tr><td>s[:n]</td><td>取前n条数据</td></tr><tr><td></td><td></td></tr></tbody></table><h5 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h5><table><thead><tr><th align="left">s.median()</th><th>series的中间值</th></tr></thead><tbody><tr><td align="left">np.shape(s)</td><td>series的矩阵形状(几行, 几列) 只有一列的话(4, )</td></tr><tr><td align="left">s.count()</td><td>Series长度，不包括NaN</td></tr><tr><td align="left">s.size</td><td>返回Series的长度,包括NaN</td></tr><tr><td align="left">len(s)</td><td>Series长度,包括NaN</td></tr><tr><td align="left">s.value_counts()</td><td>统计每个value值出现次数 返回的类型是numpy.ndarray’</td></tr><tr><td align="left">两个series相加</td><td>索引一致的，对应元素相加，无一致的索引，数据为NaN</td></tr><tr><td align="left">s.dtype</td><td>返回数据类型</td></tr><tr><td align="left">s.array</td><td>返回一个<PandasArray>或者[<code>ExtensionArray</code>]执行一些没有索引的操作时（例如，自动对齐，访问数组可能很有用 , 获取的是实际数据内的index或者Series ,永远不会复制数据</td></tr><tr><td align="left">s.name</td><td>获取series的名称属性</td></tr><tr><td align="left">s.rename</td><td>修改series的名称属性</td></tr><tr><td align="left">s.to_numpy()</td><td>返回NumPy数组 ,可能会以复制/强制值为代价</td></tr><tr><td align="left"></td><td></td></tr><tr><td align="left"></td><td></td></tr><tr><td align="left"></td><td></td></tr></tbody></table><h3 id="二-DataFrame-二维表"><a href="#二-DataFrame-二维表" class="headerlink" title="二. DataFrame 二维表"></a>二. DataFrame 二维表</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(参数,index)</span><br><span class="line">参数:一维arrays,列表,dicts</span><br><span class="line">多个array、Series长度不一样时，对应index的value值若不存在则为NaN</span><br><span class="line">当df()中给定index,并且与参数中的index不一致,以df中给定的index为准</span><br><span class="line">    s1&#x3D;np.array([1,2,4])</span><br><span class="line">    s2&#x3D;np.array([5,6,7,8])</span><br><span class="line">    df&#x3D;pd.DataFrame([s1,s2])</span><br><span class="line">参数:Series </span><br><span class="line">    s1&#x3D;pd.Series(np.array([1,2,3,4]))</span><br><span class="line">    s2&#x3D;pd.Series(np.array([5,6,7,8]))</span><br><span class="line">    df&#x3D;pd.DataFrame([s1,s2])</span><br><span class="line">    </span><br><span class="line">参数: value为Series的字典 </span><br><span class="line">    s1&#x3D;pd.Series(np.array([1,2,3,4]))</span><br><span class="line">    s2&#x3D;pd.Series(np.array([5,6,7,8]))</span><br><span class="line">    df&#x3D;pd.DataFrame(&#123;&quot;a&quot;:s1,&quot;b&quot;:s2&#125;);</span><br><span class="line">    print df</span><br><span class="line">    </span><br><span class="line">参数:通过传递元组字段来创建MultiIndexed框架---导出excle会在列名称和具体数据间多一行</span><br><span class="line">In [56]: pd.DataFrame(</span><br><span class="line">   ....:     &#123;</span><br><span class="line">   ....:         (&quot;a&quot;, &quot;b&quot;): &#123;(&quot;A&quot;, &quot;B&quot;): 1, (&quot;A&quot;, &quot;C&quot;): 2&#125;,</span><br><span class="line">   ....:         (&quot;a&quot;, &quot;a&quot;): &#123;(&quot;A&quot;, &quot;C&quot;): 3, (&quot;A&quot;, &quot;B&quot;): 4&#125;,</span><br><span class="line">   ....:         (&quot;a&quot;, &quot;c&quot;): &#123;(&quot;A&quot;, &quot;B&quot;): 5, (&quot;A&quot;, &quot;C&quot;): 6&#125;,</span><br><span class="line">   ....:         (&quot;b&quot;, &quot;a&quot;): &#123;(&quot;A&quot;, &quot;C&quot;): 7, (&quot;A&quot;, &quot;B&quot;): 8&#125;,</span><br><span class="line">   ....:         (&quot;b&quot;, &quot;b&quot;): &#123;(&quot;A&quot;, &quot;D&quot;): 9, (&quot;A&quot;, &quot;B&quot;): 10&#125;,</span><br><span class="line">   ....:     &#125;</span><br><span class="line">   ....: )</span><br><span class="line">   ....: </span><br><span class="line">    Out[56]: </span><br><span class="line">           a              b      </span><br><span class="line">           b    a    c    a     b</span><br><span class="line">    A B  1.0  4.0  5.0  8.0  10.0</span><br><span class="line">      C  2.0  3.0  6.0  7.0   NaN</span><br><span class="line">      D  NaN  NaN  NaN  NaN   9.0</span><br><span class="line">参数: 通过namedTuples列表</span><br><span class="line">namedtuples--具名列表, 元组的升级版本</span><br><span class="line">Point &#x3D; namedtuple(&quot;Point&quot;, &quot;x y&quot;)</span><br><span class="line">pd.DataFrame([Point(0, 0), Point(0, 3), (2, 3)])</span><br><span class="line">Out[59]: </span><br><span class="line">       x  y</span><br><span class="line">    0  0  0</span><br><span class="line">    1  0  3</span><br><span class="line">    2  2  3</span><br><span class="line"></span><br><span class="line">参数: dataclass传递到df中 . 传递dataclass列表等同于传递字典列表。</span><br><span class="line">Point &#x3D; make_dataclass(&quot;Point&quot;, [(&quot;x&quot;, int), (&quot;y&quot;, int)])</span><br><span class="line">    In [64]: pd.DataFrame([Point(0, 0), Point(0, 3), Point(2, 3)])</span><br><span class="line">    Out[64]: </span><br><span class="line">       x  y</span><br><span class="line">    0  0  0</span><br><span class="line">    1  0  3</span><br><span class="line">    2  2  3</span><br></pre></td></tr></table></figure><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><h5 id="1-替代构造"><a href="#1-替代构造" class="headerlink" title="1. 替代构造"></a>1. 替代构造</h5><p>DataFrame.from_dict接受dict或类似数组序列的dict并返回DataFrame,<code>DataFrame</code>除了默认的<code>orient</code>参数外，它的操作方式与构造函数类似<code>&#39;columns&#39;</code>，但默认情况下可以将其设置<code>&#39;index&#39;</code>为使用dict键作为行标签的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame.from_dict(dict([(&quot;A&quot;, [1, 2, 3]), (&quot;B&quot;, [4, 5, 6])]))</span><br><span class="line">print: </span><br><span class="line">   A  B</span><br><span class="line">0  1  4</span><br><span class="line">1  2  5</span><br><span class="line">2  3  6</span><br><span class="line"></span><br><span class="line">In [66]: pd.DataFrame.from_dict(</span><br><span class="line">   ....:     dict([(&quot;A&quot;, [1, 2, 3]), (&quot;B&quot;, [4, 5, 6])]),</span><br><span class="line">   ....:     orient&#x3D;&quot;index&quot;,</span><br><span class="line">   ....:     columns&#x3D;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;],</span><br><span class="line">   ....: )</span><br><span class="line">   ....: </span><br><span class="line">Out[66]: </span><br><span class="line">   one  two  three</span><br><span class="line">A    1    2      3</span><br><span class="line">B    4    5      6</span><br></pre></td></tr></table></figure><h5 id="2-取值-添加-删除"><a href="#2-取值-添加-删除" class="headerlink" title="2.取值,添加,删除"></a>2.取值,添加,删除</h5><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>df[“列名”]</td><td>选择某一列</td></tr><tr><td>df[“新增列名] = df[“原列名”]*df[“原列名”]</td><td>根据原来的列数据,通过计算, 新增一行新的列, 条件可以设置多样, 如果df[“原列名”]&gt;2 等等</td></tr><tr><td>del.df[“列名”]</td><td>删除某一列</td></tr><tr><td>df.pop(“列名”)</td><td>弹出某一列 ,相当于删除</td></tr><tr><td>df.insert()</td><td>插入列, 可指定插入位置df.insert(1:, “bar”, df[“one”]) , 1为指定的插入位置, bar为列名, df[“one”]为数据源</td></tr><tr><td>df.assign(列名 = 原列计算)</td><td>类似第二种方法, 从现有列派生新列 :        df2 = df.assign(d = df[“a”]/df[“c”]) , 但是返回的是一个新的df  , 原来的df不变</td></tr><tr><td>df.loc[条件]</td><td>打印符合条件的数据行 如: 条件 = df.数据&gt;6 , 返回的是series</td></tr><tr><td>df.iloc[1]</td><td>按整数位置选择行, 如1 为整个表格的第二行 ,返回的是一个series, index引用原来的列名</td></tr><tr><td>df[n: m]</td><td>切片选择行, 返回的是df</td></tr><tr><td>df.列名</td><td>如果DataFrame列标签是有效的Python变量名称，则可以像访问属性一样访问该列</td></tr><tr><td></td><td></td></tr></tbody></table><h5 id="2-属性-1"><a href="#2-属性-1" class="headerlink" title="2. 属性"></a>2. 属性</h5><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>df.T</td><td>表格转置</td></tr><tr><td>df.info</td><td>获取df的摘要信息</td></tr><tr><td>df.to_string</td><td>会以表格形式返回DataFrame的字符串表示形式</td></tr><tr><td>df.shape</td><td>给出对象的轴尺寸  ( 索引,列)</td></tr><tr><td>df.head()</td><td></td></tr><tr><td>df.tail()</td><td></td></tr><tr><td>df.items</td><td></td></tr><tr><td>df.keys()</td><td></td></tr><tr><td>df.values</td><td>返回df的值, 不建议使用 , 当DataFrame包含多种数据类型时DataFrame.values可能涉及将数据复制和将值强制转换为通用dtype</td></tr><tr><td>df.to_numpy()</td><td>可以使返回的NumPy数组可能不是DataFrame中相同数据的视图更加清楚</td></tr><tr><td>df.ix(条件, 某列名) = ???</td><td>if-then操作 :  根据条件,修改某列的信息为???           df.ix[df.A &gt; 1,’B’]= -1  A列数据&gt;1的时候, B的对应数据=-1</td></tr><tr><td>np.where(条件, then, else)</td><td>df[“列名”]=np.where(df.A&lt;3, 1, 0) , 根据条件来显示信息</td></tr><tr><td>df.groupby()</td><td>根据相应的条件形成组 , 见以下代码</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df &#x3D; pd.DataFrame(&#123;&#39;animal&#39;: &#39;cat dog cat fish dog cat cat&#39;.split(),</span><br><span class="line">                         &#39;size&#39;: list(&#39;SSMMMLL&#39;),</span><br><span class="line">                         &#39;weight&#39;: [8, 10, 11, 1, 20, 12, 12],</span><br><span class="line">                         &#39;adult&#39; : [False] * 5 + [True] * 2&#125;);</span><br><span class="line">       print df</span><br><span class="line">       # 列出每种动物中weight最大的对应size</span><br><span class="line">       group&#x3D;df.groupby(&quot;animal&quot;).apply(lambda subf: subf[&#39;size&#39;][subf[&#39;weight&#39;].idxmax()])</span><br><span class="line">       ————————————————</span><br><span class="line">   df.get_group 取出其中一分组</span><br><span class="line">       df.groupby(animal).get_group(&quot;cat&quot;)</span><br></pre></td></tr></table></figure><h3 id="pd-read-excle"><a href="#pd-read-excle" class="headerlink" title="pd.read_excle"></a>pd.read_excle</h3><p>读取文件, 可以设置读取的条件, 进行部分读取</p><p>​<br>    方法<br>    df = pd.read_excle(参数:)<br>    df.head() 默认输出前5行数据 , 可修改默认值 </p><p>​    </p><p>​    </p><p> <img src="E:%5Cproject%5Cblog%5Csource_posts%5Cimages%5C12.jpg" alt="参数列表" loading="lazy"></p><ol><li>操作问题<br>报错:  Unsupported format, or corrupt file: Expected BOF record; found b’\xd0\xd5\xc3\xfb\t\xb5\xe7\xbb’<br>原因: 可能是因为excle表格不对, 我是直接在idea中创建的xlsx的文件,跟正常创建的excle不一样</li></ol><blockquote><p>xlrd, xlwt等<br>两者的不同之处  </p></blockquote><h2 id="gt-python3新增数据类型"><a href="#gt-python3新增数据类型" class="headerlink" title="&gt;python3新增数据类型"></a>&gt;python3新增数据类型</h2><h3 id="namedtuples"><a href="#namedtuples" class="headerlink" title="namedtuples"></a>namedtuples</h3><p>​    <strong>Python元组的升级版本 – namedtuple(具名元组)</strong></p><p>因元组的局限性：不能为元组内部的数据进行命名，从而不知道一个元组所要表达的意义，故引入了 <strong>collections.namedtuple</strong> 工厂函数，构造一个带字段名的元组。</p><p>具名元组的实例和普通元组消耗的内存一样多，因字段名都被存在对应的类里面。这个类跟普通的对象实例比起来也要小一些，因为 Python 不会用– <strong>dict</strong> –来存放这些实例的属性</p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>collections.namedtuple(typename:元组名称, field_names元组中元素名称, verbose=False:默认就好, rename=False:如果元素名称中含有 python 的关键字，则必须设置为 True) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import collections as cl</span><br><span class="line"># 定义一个具名元组 是个类</span><br><span class="line">User &#x3D; cl.namedtuple(typename&#x3D;&quot;user&quot;,field_names&#x3D;[&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;])</span><br><span class="line"># 从类中创建对象</span><br><span class="line"># 方法一</span><br><span class="line">user &#x3D; User(&quot;bob&quot;,12,&quot;male&quot;)</span><br><span class="line">print(user)</span><br><span class="line"># 打印user所有字段名</span><br><span class="line">print(user._fields)</span><br><span class="line"></span><br><span class="line"># 方法二 :通过一个list来创建一个User对象，这里注意需要使用&quot;_make&quot;方法</span><br><span class="line">user &#x3D; User._make([&quot;bob&quot;,12,&quot;male&quot;])</span><br><span class="line">print(user)</span><br><span class="line"># 打印user所有字段名</span><br><span class="line">print(user._fields)</span><br><span class="line"></span><br><span class="line"># 获取属性</span><br><span class="line">print(user.name)</span><br><span class="line">print(user.index(&quot;bob&quot;))</span><br></pre></td></tr></table></figure><h2 id="gt-灵活的二进制运算"><a href="#gt-灵活的二进制运算" class="headerlink" title="&gt;灵活的二进制运算"></a>&gt;灵活的二进制运算</h2><h3 id="一-series-和df的匹配表现"><a href="#一-series-和df的匹配表现" class="headerlink" title="一. series 和df的匹配表现"></a>一. series 和df的匹配表现</h3><h4 id="执行二进制运算的方法"><a href="#执行二进制运算的方法" class="headerlink" title="执行二进制运算的方法"></a>执行二进制运算的方法</h4><p>df.add()，sub()  , mul(),  div(), radd() , rsub() </p><h4 id="axis关键字"><a href="#axis关键字" class="headerlink" title="axis关键字"></a>axis关键字</h4><p>用于在<em>索引</em>或<em>列</em>上进行匹配</p><p>DataFrame.sub（<strong><em>其他<em>，</em>axis = ‘columns’<em>，</em>级别= None<em>，</em>fill_value = None</em></strong>）**</p><p>参数</p><ul><li><p><strong>其他</strong> :</p><p>标量，序列，系列或DataFrame</p><p>任何单个或多个元素的数据结构，或类似列表的对象。</p></li><li><p><strong>轴</strong>{0或’index’，1或’columns’}</p><p>是按索引（0或“索引”）还是按列（1或“列”）进行比较。对于系列输入，轴上要匹配系列索引。</p></li><li><p><strong>级别</strong>int或标签</p><p>在一个级别上匹配，在传递的MultiIndex级别上匹配索引值。</p></li><li><p><strong>fill_value</strong> float或无，默认为无</p><p>在计算之前，请使用此值填充现有的缺失（NaN）值以及成功完成DataFrame对齐所需的任何新元素。如果两个对应的DataFrame位置中的数据均丢失，则结果将丢失。</p></li></ul><p>返回值</p><ul><li><p>数据框</p><p>算术运算的结果。</p></li></ul><p>参考文章:<br><a href="">参考链接</a><br><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html">pandas的手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘要: pandas &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;pandas&quot;&gt;&lt;a href=&quot;#pandas&quot; class=&quot;headerlink&quot; title=&quot;pandas&quot;&gt;&lt;/a&gt;pandas&lt;/h1&gt;&lt;p&gt;pandas 是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>html标签复习</title>
    <link href="http://lvwi.github.io/2021/03/29/html%E6%A0%87%E7%AD%BE%E5%A4%8D%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2021/03/29/html%E6%A0%87%E7%AD%BE%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-03-29T06:39:04.000Z</published>
    <updated>2021-04-06T07:36:49.414Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>标签 </p></blockquote><p><meta->标签  </p><p>一. 标签的定义  </p><blockquote><p>用来为搜索引擎定义页面主题<br>    定义用户浏览器上的cookie<br>    可以用来鉴别作者<br>    设定页面格式<br>    标注内容提要和关键字</p></blockquote><p>二、标签属性  </p><blockquote><p>http-equiv：标题信息, 类似http头部协议,回应给浏览器一些信息,来正确显示网页内容</p></blockquote><table><thead><tr><th align="left">常用值</th><th align="left">功能</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">Content-Type</td><td align="left">设定字符集,说明页面用的文字及语言</td><td align="left">用法：&lt;Meta http-equiv=”Content-Type” Content=”text/html; Charset=gb2312”–&gt;</td></tr><tr><td align="left">Refresh</td><td align="left">刷新 让网页多长时间（秒）刷新自己，或在多长时间后让网页自动链接到其它网页</td><td align="left">Meta http-equiv=”Refresh” Content=”5; Url=<a href="http://www.xia8.net&quot;" target="_blank" rel="noopener">http://www.xia8.net&quot;</a></td></tr><tr><td align="left">Expires (期限)</td><td align="left">指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调阅</td><td align="left">Meta http-equiv=”Expires” Content=”Wed, 26 Feb 1997 08:21:57 GMT”</td></tr><tr><td align="left">Pragma (cach模式)</td><td align="left">禁止浏览器从本地机的缓存中调阅页面内容。</td><td align="left">Meta http-equiv=”Pragma” Content=”No-cach” 网页不保存在缓存中，每次访问都刷新页面。  这样设定，访问者将无法脱机浏览</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设定cookie</td><td align="left">Meta http-equiv=”Set-Cookie” Content=”cookievalue=xxx; expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/“</td></tr><tr><td align="left">Window-target</td><td align="left">显示窗口设定:强制页面在当前窗口以独立页面显示</td><td align="left">Meta http-equiv=”Widow-target” Content=”_top”   这个属性是用来防止别人在框架里调用你的页面。Content选项：_blank、_top、_self、_parent</td></tr><tr><td align="left">Pics-label (网页RSAC等级评定)</td><td align="left">防止浏览一些受限制的网站，而网站的限制级别就是通过该参数来设置的</td><td align="left">\META http-equiv=”Pics-label” Contect=”(PICS－1.1’http:\<a href="http://www.rsac.org\ratingsv01.html&#39;I" target="_blank" rel="noopener">www.rsac.org\ratingsv01.html&#39;I</a> gen comment ‘RSACi North America Sever’ by ‘inet@microsoft.com’ for ‘http:\<a href="http://www.microsoft.com&#39;" target="_blank" rel="noopener">www.microsoft.com&#39;</a> on ‘1997.06.30T14:21－0500’ r(n0 s0 v0 l0))”</td></tr><tr><td align="left">Page-Enter、Page-Exit (进入与退出)</td><td align="left">是页面被载入和调出时的一些特效</td><td align="left">Meta http-equiv=”Page-Enter” Content=”blendTrans(Duration=0.5) blendTrans是动态滤镜的一种，产生渐隐效果。  另一种动态滤镜RevealTrans也可以用于页面进入与退出效果 Meta http-equiv=”Page-Enter” Content=”revealTrans(duration=x : 持续时间, transition=y) :滤镜类型 0-23”</td></tr><tr><td align="left">Content-Script-Type (脚本相关)</td><td align="left">这是近来W3C的规范，指明页面中脚本的类型。</td><td align="left">Meta http-equiv=”Content-Script-Type” Content=”text/javascript”</td></tr></tbody></table><blockquote><p>name：页面描述信息<br>name是描述网页的，对应于Content（网页内容），以便于搜索引擎机器人查找、分类（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）<br>name的value值（name=””）指定所提供信息的类型。有些值是已经定义好的。例如description(说明)、keyword(关键字)、refresh(刷新)等。还可以指定其他任意值，如：creationdate(创建日期) 、document ID(文档编号)和level(等级)等。</p></blockquote><table><thead><tr><th align="left">常用值</th><th align="left">功能</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">Keywords (关键字)</td><td align="left">为搜索引擎提供的关键字列表</td><td align="left">Meta name=”Keywords” Lang=”EN” Content=”关键词1,关键词2，关键词3,关键词4,……” 当有多个meta指定关键词时,会根据lang的属性来进行区分</td></tr><tr><td align="left">Description (简介)</td><td align="left">Description用来告诉搜索引擎你的网站主要内容</td><td align="left">Meta name=”Description” Content=”你网页的简述”</td></tr><tr><td align="left">Robots (机器人向导)</td><td align="left">Robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。Content的参数有all、none、index、noindex、follow、nofollow。默认是all。</td><td align="left">Meta name=”Robots” Content=”All\None\Index\Noindex\Follow\Nofollow”   “all：文件将被检索，且页面上的链接可以被查询；  none：文件将不被检索，且页面上的链接不可以被查询；(和 “noindex, no follow” 起相同作用)   index：文件将被检索；（让robot/spider登录）  follow：页面上的链接可以被查询；  noindex：文件将不被检索，但页面上的链接可以被查询；(不让robot/spider登录)  nofollow：文件将不被检索，页面上的链接可以被查询。(不让robot/spider顺着此页的连接往下探找)”</td></tr><tr><td align="left">Author (作者)</td><td align="left"></td><td align="left">Meta name=”Author” Content=”张三，<a href="mailto:abc@sina.com">abc@sina.com</a>“</td></tr><tr><td align="left">Copyright (版权)</td><td align="left"></td><td align="left">Meta name=”Copyright” Content=”本页版权归Zerospace所有。All Rights Reserved”</td></tr><tr><td align="left">Generator (编辑器)</td><td align="left"></td><td align="left">Meta name=”Generator” Content=”PCDATA\FrontPage&quot;</td></tr><tr><td align="left">revisit-after (重访)</td><td align="left"></td><td align="left">META name=”revisit-after” CONTENT=”7 days”</td></tr><tr><td align="left">Viewport</td><td align="left">用于在手机浏览器上控制布局,用于响应式设计</td><td align="left">Content=”width=device-width,initial-scale=1,maximum-scale=1″手机浏览器把页面放在一个虚拟的窗口(viewport)中,这样就不会把每个网页都挤在一个很小的窗口中,从而破坏哪些没有经过优化的页面布局.用户可以通过滑动和缩放来查看页面的内容.</td></tr></tbody></table><blockquote><p>css</p></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;标签 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;meta-&gt;标签  &lt;/p&gt;
&lt;p&gt;一. 标签的定义  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来为搜索引擎定义页面主题&lt;br&gt;    定义用户浏览器上的cookie&lt;br&gt;   
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>layui学习</title>
    <link href="http://lvwi.github.io/2021/03/24/layui%E5%AD%A6%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2021/03/24/layui%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-24T08:54:06.000Z</published>
    <updated>2021-03-24T08:54:06.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>首页显示摘要内容（替换成自己的）</p><a id="more"></a><p>正文内容（替换成自己的）</p></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;首页显示摘要内容（替换成自己的）&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java项目与python结合</title>
    <link href="http://lvwi.github.io/2021/03/24/java%E9%A1%B9%E7%9B%AE%E4%B8%8Epython%E7%BB%93%E5%90%88/"/>
    <id>http://lvwi.github.io/2021/03/24/java%E9%A1%B9%E7%9B%AE%E4%B8%8Epython%E7%BB%93%E5%90%88/</id>
    <published>2021-03-24T08:53:37.000Z</published>
    <updated>2021-04-06T08:45:02.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>java ,python</p><a id="more"></a><p>java与python结合</p></blockquote><ol><li>在java类中直接使用python语句  <blockquote><p>导入依赖: Jpython</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.python&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jython-standalone&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li>在java类中创建interpreter ,但是引用不到, 要先建main方法 </li><li>或者用runtime.getRuntime().exec(调动python运行python文件),创建输入输出流进行<br>“gb2312” 是用来应对中文报错的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        PythonInterpreter inp = new PythonInterpreter();</span></span><br><span class="line"><span class="comment">//        inp.exec("a = (\"hello\",\"world\")\n" +</span></span><br><span class="line"><span class="comment">//                "print(\"*\".join(a))");</span></span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        String[] arg = <span class="keyword">new</span> String[]&#123;<span class="string">"python"</span>,<span class="string">"E:\\project\\shiyu2021\\src\\main\\resources\\forJavaAndP.py"</span>&#125;;</span><br><span class="line">        Process process = Runtime.getRuntime().exec(arg);</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream(),<span class="string">"gb2312"</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"没有内容"</span>);</span><br><span class="line">        bufferedReader.close();</span><br></pre></td></tr></table></figure></li></ol><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;java ,python&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>复习maven及maven项目</title>
    <link href="http://lvwi.github.io/2021/03/23/%E5%A4%8D%E4%B9%A0maven%E5%8F%8Ajava%E9%A1%B9%E7%9B%AE/"/>
    <id>http://lvwi.github.io/2021/03/23/%E5%A4%8D%E4%B9%A0maven%E5%8F%8Ajava%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-03-23T02:25:13.000Z</published>
    <updated>2021-03-24T08:29:03.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>首页显示摘要内容（替换成自己的）</p><a id="more"></a><p>正文内容（替换成自己的）</p></blockquote><ol><li>maven  下载</li><li>maven  安装及本地仓库配置</li><li>maven  环境变量配置 新建M2_HOME 是maven的地址; path中配置: bin路径</li><li>maven  在idea中配置</li><li>maven  pom.xml的配置: <a href="http://mvnrepository.com/可到此网址中查询对应的工具" target="_blank" rel="noopener">http://mvnrepository.com/可到此网址中查询对应的工具</a></li><li>maven项目的配置  <blockquote><p>(1) webapp目录, 需要标记为web项目的资源目录(project Settings –&gt;moudles–&gt;新增web–&gt;设置web.xml目录; 设置项目webapp目录)<br> (2) artifact: 编译后的Java类，Web资源等的整合,用以测试、部署等工作:就是设置某个module的打包方式  </p><pre><code>module有了 Artifacts 就可以部署到应用服务器中 </code></pre></blockquote></li><li>打包方式:<br> jar：Java ARchive，通常用于聚合大量的Java类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发Java平台应用软件或库；<br> war：Web application ARchive，一种JAR文件，其中包含用来分发的JSP、Java Servlet、Java类、XML文件、标签库、静态网页（HTML和相关文件），以及构成Web应用程序的其他资源；<br> exploded：在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。       </li><li>idea配置数据库, 一直报错: Connection to practice@localhost failed. [08001] Could not create connection to database server. Attempted reconnect 3 times. Giving up.<br> 解决方法: 链接后面加上 ?useSSL=false&amp;serverTimezone=UTC </li><li>运行链接数据库报错: Connections could not be acquired from the underlying database!  ; java.sql.SQLException: No suitable driver<br> 发现是配置文件中数据库密码错误 以及 c3p0.xml的位置错误, 这个文件要放在java对应的resources里面<br>参考文章:<br><a href="https://blog.csdn.net/mmmxsblogs/article/details/89195859?ops_request_misc=&request_id=&biz_id=102&utm_term=ideanmaven%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-89195859.pc_search_result_cache" target="_blank" rel="noopener">IDEA详细配置并详细创建Maven项目 -(idea)</a><br><a href="https://blog.csdn.net/qq_32180027/article/details/70306158?utm_term=idea%E4%B8%AD%E9%85%8D%E7%BD%AEartifacts&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-6-70306158&spm=3001.4430" target="_blank" rel="noopener">IDEA Artifacts配置说明</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;首页显示摘要内容（替换成自己的）&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python基础操作积累</title>
    <link href="http://lvwi.github.io/2021/03/16/python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%A7%AF%E7%B4%AF/"/>
    <id>http://lvwi.github.io/2021/03/16/python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%A7%AF%E7%B4%AF/</id>
    <published>2021-03-16T08:19:21.000Z</published>
    <updated>2021-03-16T09:05:37.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>首页显示摘要内容（替换成自己的）</p><a id="more"></a><p>正文内容（替换成自己的）</p></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;首页显示摘要内容（替换成自己的）&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python常用函数备查.md</title>
    <link href="http://lvwi.github.io/2021/03/08/python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%A4%87%E6%9F%A5/"/>
    <id>http://lvwi.github.io/2021/03/08/python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%A4%87%E6%9F%A5/</id>
    <published>2021-03-08T06:21:03.000Z</published>
    <updated>2021-03-16T08:17:38.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>python常用函数<br>python常用的函数及操作</p><a id="more"></a></blockquote><ol><li><p>filter(function,list)</p><ul><li>filter()函数是python内置的另一个有用的高阶函数</li><li>filter()函数接收一个函数f和一个list,</li><li>这个函数f的作用是对每个元素进行判断,返回True或False</li><li>filter()根据判断结果自动过滤掉不符合条件的元素</li></ul></li><li><p>如何将python文件打包成exe<br> (1) 找到需要打包的文件所在文件夹<br> (2) win + r 进到cmd页面, 安装pip install pyinstaller<br> (3) cd 到刚才的文件夹路径下</p> <img src='ptyheon打包操作界面1' loading="lazy">   ![](images/python打包操作界面1.jpg)   (4) 输入命令 pyinstaller --console --onefile xxxx.py   (5) 生成成功，在工程目录下有一个dist文件夹</li><li><p>生成折线图等<br> (1)画图不支持中文,但是可以导入字体来解决,或者在用的时候设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span>  plt</span><br><span class="line"> <span class="comment"># 方法1</span></span><br><span class="line"><span class="comment"># fname 为 你下载的字体库路径，注意 SourceHanSansSC-Bold.otf 字体的路径</span></span><br><span class="line">zhfont1 = matplotlib.font_manager.FontProperties(fname=<span class="string">"SourceHanSansSC-Bold.otf"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"x 轴"</span>, fontproperties=zhfont1)  </span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">plt.xlabel(<span class="string">"x轴"</span>,fontproperties=<span class="string">"SimSun"</span>) <span class="comment">#宋体</span></span><br></pre></td></tr></table></figure></li><li><p>subplot()<br>subplot() 函数允许你在同一图中绘制不同的东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span>  plt</span><br><span class="line">x = np.arange(<span class="number">0</span>,  <span class="number">3</span>  * np.pi,  <span class="number">0.1</span>) </span><br><span class="line">y_sin = np.sin(x) </span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line">plt.subplot(<span class="number">2</span>,  <span class="number">1</span>,  <span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 绘制第一个图像 </span></span><br><span class="line">plt.plot(x, y_sin) </span><br><span class="line">plt.title(<span class="string">'Sine'</span>)  </span><br><span class="line"><span class="comment"># 将第二个 subplot 激活，并绘制第二个图像</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>) </span><br><span class="line">plt.plot(x, y_cos) </span><br><span class="line">plt.title(<span class="string">'Cosine'</span>)</span><br></pre></td></tr></table></figure><p>plt.bar()</p></li></ol><p>4 . 填充函数  </p><blockquote><p>填充fill(<em>args, *</em>kwargs)<br>args - sequence of x, y, [color]</p></blockquote><blockquote><p>区域填充fill_between<br>plt.plot(x, y)   # 先将图画出来<br>plt.fill_between(x, 0, y, facecolor=’green’, alpha=0.3)<br>plt.show()<br>可以看到，我用了这个函数的几个参数：<br>x：第一个参数表示覆盖的区域，我直接复制为x，表示整个x都覆盖<br>0：表示覆盖的下限<br>y：表示覆盖的上限是y这个曲线<br>facecolor：覆盖区域的颜色<br>alpha：覆盖区域的透明度[0,1],其值越大，表示越不透明  </p></blockquote><p>参考文章:<br><a href="https://www.runoob.com/numpy/numpy-matplotlib.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;python常用函数&lt;br&gt;python常用的函数及操作&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python爬虫学习</title>
    <link href="http://lvwi.github.io/2021/03/02/python%E7%88%AC%E8%99%AB%E8%AE%B0%E5%BD%95/"/>
    <id>http://lvwi.github.io/2021/03/02/python%E7%88%AC%E8%99%AB%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-02T07:50:15.000Z</published>
    <updated>2021-05-31T07:51:34.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python爬虫读取网页上的音频"><a href="#python爬虫读取网页上的音频" class="headerlink" title="python爬虫读取网页上的音频"></a>python爬虫读取网页上的音频</h1><h2 id="第一步-爬虫需要request模块-先导入"><a href="#第一步-爬虫需要request模块-先导入" class="headerlink" title="第一步  爬虫需要request模块,先导入"></a>第一步  爬虫需要request模块,先导入</h2><h2 id="第二步-代码编写"><a href="#第二步-代码编写" class="headerlink" title="第二步  代码编写"></a>第二步  代码编写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __*__coding=utf-8__*__</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">url = <span class="string">"http://www.2uxs.com/play/2443_1_4785.html"</span></span><br><span class="line">urlEnd = <span class="string">"http://www.2uxs.com/play/2443_1_5538.html"</span></span><br><span class="line">downloadUrl = <span class="string">"https://t3344.tingchina.com/yousheng/都市言情/庶女攻略_悠然梦/050_烟火(上).mp3?key=542d0da969ddda686242fda6d7bb6ab5_668011838"</span></span><br><span class="line">downloadUrls = downloadUrl.split(<span class="string">"?"</span>)</span><br><span class="line">dU = downloadUrls[<span class="number">0</span>].split(<span class="string">"梦/"</span>)</span><br><span class="line"><span class="comment"># 截取网址信息</span></span><br><span class="line">urls = url.split(<span class="string">"_1_"</span>)</span><br><span class="line">num = urls[<span class="number">1</span>].split(<span class="string">"."</span>)</span><br><span class="line"><span class="comment"># print(urls[0], "_1_", num[0], ".", num[1])</span></span><br><span class="line"><span class="comment"># 遍历获取网址</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4785</span>, <span class="number">4786</span>):</span><br><span class="line">    <span class="comment"># 组合网址</span></span><br><span class="line">    newUrl = urls[<span class="number">0</span>]+<span class="string">"_1_"</span>+str(i) + <span class="string">"."</span>+ num[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#    获取网页信息</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.1 Safari/605.1.15'</span></span><br><span class="line">    &#125;</span><br><span class="line">    msg = requests.get(newUrl, headers)</span><br><span class="line">    <span class="comment"># 用bs4解析网页</span></span><br><span class="line">    soup = BeautifulSoup(msg.text, <span class="string">"lxml"</span>)</span><br><span class="line">    h1Name = soup.h1.string</span><br><span class="line">    voiceNname = str(h1Name).split(<span class="string">"："</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 获取当前网页播放的文件名称</span></span><br><span class="line">    print(voiceNname)</span><br><span class="line">    <span class="comment"># 获取下载的新网址</span></span><br><span class="line">    newDU = dU[<span class="number">0</span>] + <span class="string">"梦/"</span>+voiceNname+<span class="string">"?"</span>+downloadUrls[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># voice = requests.get(newDU,headers)</span></span><br><span class="line">    print(newDU)</span><br><span class="line">    <span class="comment"># listA = soup.find_all("audio",&#123;"id": "jp_audio_0"&#125;)</span></span><br><span class="line">    <span class="comment"># print(listA)</span></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>网页中audio是在iframe框架中的, 获取的soup中没有此模块信息</li><li>换了方式, 根据下载链接的格式, 直接获取下载链接, 但是访问时无信息响应(是因为key超时的问题)</li><li>无法直接下载内容后, 想要批量获取下载链接,保存到表格中, 但是程序运行超过100回后,在后续会报错数组下标越界</li><li>无法解决下载链接中key会变的问题, 导致下载的时候报错404</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"># voiceNname = str(h1Name).split("：")[1]</span></span><br><span class="line"><span class="comment"># IndexError: list index out of range</span></span><br></pre></td></tr></table></figure><p>处理方法一: 配置多个User-Agent, 多次会报错</p><h2 id="bs4的使用"><a href="#bs4的使用" class="headerlink" title="bs4的使用"></a>bs4的使用</h2><p>beautifulSoup的使用: 如何根据标签读取内容<br><code>msg = requests.get(url, headers) soup = bf(msg.text,&quot;lxml&quot;)</code><br>soup 是BeaufifulSoup类型的对象</p><blockquote><p>soup.element tag子节点<br>soup.div.name,获取的标签的名称<br>soup.div.attrs 获取标签节点的属性, 返回一个key:value形式的字典<br>soup,div[“id”]获取某一个属性的属性值, 若属性值有多个,返回的是一个列表<br>soup.div.string 获取节点之间的text文本<br>soup.head.contents 获取直接子节点, 返回一个列表<br>soup.head.contents[3] 根据索引从所有节点中取出某一个<br>res = soup.head.children 返回的是列表生成器对象<br>    <code>for ele in res:               print(ele)            for循环比那里子节点,ele就是子节点</code><br>soup.body.descendants 获取子孙节点,包含子节点,孙节点,每个子节点的内容,返回的是一个生成器对象<br>soup.title.parent 获取子节点的父节点<br>soup.meta.next_sibling.next_sibling 获取节点的下一个兄弟节点<br>soup.meta.previous_sibling 获取节点的上一个兄弟节点    </p></blockquote><p>搜索文档树中的数据</p><blockquote><p>soup.find_all(“p”) 直接通过标签名查找标签,<br>soup.find_all([“p”,”a”])可以同时查找多个标签<br>soup.find(id=”top”) 查找唯一标签<br>soup.find_all(class_=”two) ,通过类名查找,不能直接写class,因为class是python关键字,所以加_<br>soup.select(“#data”)通过css选择器查找标签,返回的是列表,列表中存放的是查找到的标签<br>soup.select(a[target=”_blank”]) 通过制定标签名,指定属性值,查找<br>soup.select(“div .spider”)通过找某个标签下的指定属性值的标签  </p></blockquote><h2 id="xlwt-xlrd使用"><a href="#xlwt-xlrd使用" class="headerlink" title="xlwt,xlrd使用"></a>xlwt,xlrd使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wb = xlwt.Workbook()  </span><br><span class="line">ws = wb.add_sheet(<span class="string">"sheet的名字);</span></span><br><span class="line"><span class="string">ws.write(行坐标,列坐标,数据信息);</span></span><br><span class="line"><span class="string">ws.save("</span>表格名称<span class="string">")</span></span><br></pre></td></tr></table></figure><h3 id="EXCLE公式使用"><a href="#EXCLE公式使用" class="headerlink" title="EXCLE公式使用"></a>EXCLE公式使用</h3><p>=RIGHT(A2,LEN(A2)-2) excel表格数字批量去除前2位字符的方法</p><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python爬虫读取网页上的音频&quot;&gt;&lt;a href=&quot;#python爬虫读取网页上的音频&quot; class=&quot;headerlink&quot; title=&quot;python爬虫读取网页上的音频&quot;&gt;&lt;/a&gt;python爬虫读取网页上的音频&lt;/h1&gt;&lt;h2 id=&quot;第一步-爬虫需要r
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>利用python修改图片名称为时间</title>
    <link href="http://lvwi.github.io/2020/10/27/%E5%88%A9%E7%94%A8python%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E5%90%8D%E7%A7%B0%E4%B8%BA%E6%97%B6%E9%97%B4/"/>
    <id>http://lvwi.github.io/2020/10/27/%E5%88%A9%E7%94%A8python%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E5%90%8D%E7%A7%B0%E4%B8%BA%E6%97%B6%E9%97%B4/</id>
    <published>2020-10-27T03:31:22.579Z</published>
    <updated>2020-10-27T03:04:59.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python知识点"><a href="#python知识点" class="headerlink" title="python知识点"></a>python知识点</h3><ul><li><p>python文件夹里的”__ init __.py”文件的作用</p><ol><li><p>python中package的标识，它可以什么也不定义；可以只是一个空文件，但是必须存在，不能删除。</p></li><li><p>我们可以在__ init__.py导入我们需要的模块，不需要一个个导入了。</p></li><li><p>__ init __ .py  中还有一个重要的变量，__ all __, 它用来将模块全部导入</p></li></ol></li><li></li><li></li></ul><h3 id="利用python修改图片名称为时间"><a href="#利用python修改图片名称为时间" class="headerlink" title="利用python修改图片名称为时间"></a>利用python修改图片名称为时间</h3><p>工具: python及第三方库exifread</p><ol><li><p>安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install exifread</span><br></pre></td></tr></table></figure><p>使用Python exifread 库就能够轻松的实现图片的定位</p><p>exifread.process_file() 这个方法可以获取图片信息</p></li><li><p>修改图片名称的步骤</p><ol><li><p>获取图片地址  (os模块)</p></li><li><p>获取图片名称和扩展名</p></li><li><p>要讲图片名称重命名为拍摄时间, 需要获取时间</p><p>目前只是修改有拍摄时间的图片名称, 视频或者mov,jpeg格式的图片暂时没有包含在内</p></li><li><p>修改名称使用os.rename()</p></li><li><p>代码如下</p></li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取图片列表</span></span><br><span class="line">old_path=<span class="string">" 需要填写"</span></span><br><span class="line">filelist = os.listdir(old_path)</span><br><span class="line">newFilelist = []</span><br><span class="line"><span class="comment"># i用于防止图片名称重复</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="comment"># 2.循环获取文件的名称</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">    fpath = old_path+<span class="string">"/"</span>+item</span><br><span class="line">    f = open(fpath, <span class="string">"rb"</span>)</span><br><span class="line">    imgType = item.split(<span class="string">"."</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> imgType != <span class="string">"MP4"</span>:</span><br><span class="line">        tags = exifread.process_file(f)</span><br><span class="line">        newpath = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 取出图片的拍摄时间: 先判断tags中有没有属性"Image DateTime"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Image DateTime"</span> <span class="keyword">in</span> tags.keys():</span><br><span class="line">            <span class="comment"># 获取图片的格式</span></span><br><span class="line">            <span class="comment"># 获取图片的拍摄时间</span></span><br><span class="line">            datetime = tags[<span class="string">"Image DateTime"</span>]</span><br><span class="line">            ctime = str(datetime).split(<span class="string">" "</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> ctime <span class="keyword">in</span> newFilelist:</span><br><span class="line">                ctime += str(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            newFilelist.append(ctime)</span><br><span class="line">            <span class="comment"># 修改时间格式 2019:04:01为 20190401, 先用splite分割为list,然后再连接</span></span><br><span class="line">            newname = <span class="string">""</span>.join(ctime.split(<span class="string">":"</span>))+<span class="string">"."</span>+imgType</span><br><span class="line">            f.close()</span><br><span class="line">            <span class="comment"># 新图片的地址</span></span><br><span class="line">            newpath = old_path+<span class="string">"/"</span>+newname</span><br><span class="line">            os.rename(fpath, newpath)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python知识点&quot;&gt;&lt;a href=&quot;#python知识点&quot; class=&quot;headerlink&quot; title=&quot;python知识点&quot;&gt;&lt;/a&gt;python知识点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;python文件夹里的”__ init __.py”文件的作用&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDBC--oracle数据库</title>
    <link href="http://lvwi.github.io/2020/04/23/JDBC-oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://lvwi.github.io/2020/04/23/JDBC-oracle%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-04-23T11:45:30.000Z</published>
    <updated>2020-04-23T11:45:53.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>JDBC–oracle数据库</p><a id="more"></a><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>JDBC的本质是一套规范一套接口，是SUN定义的J2EE规范之一。</p><p>所有的java程序员面向JDBC接口调用，所有的数据库厂商程序员面向JDBC规范实现。</p><p>实现类被称作“驱动”。驱动以jar结尾</p><p>jar包: 最初的方式:在classpath 中配置 </p><p>​     CLASSPATH= ;E:\oracle\product\10.2.0\db_1\jdbc\lib\ojdbc14.jar</p><h4 id="JDBC编程六步曲"><a href="#JDBC编程六步曲" class="headerlink" title="JDBC编程六步曲"></a>JDBC编程六步曲</h4><h5 id="注册驱动"><a href="#注册驱动" class="headerlink" title="注册驱动"></a>注册驱动</h5><p>方式1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.sql.Driver driver = new oracle.jdbc.driver.OracleDriver(); 创建驱动对象</span><br><span class="line">java.sql.DriverManager.registerDriver(driver);<span class="comment">--注册驱动</span></span><br></pre></td></tr></table></figure><p>方式2</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(“oracle.jdbc.driver.OracleDriver”);</span><br><span class="line">原理：</span><br><span class="line">package oracle.jdbc.driver;</span><br><span class="line">public class OracleDriver&#123;</span><br><span class="line">  static&#123;</span><br><span class="line">    Driver d = new OracleDriver();</span><br><span class="line">    DriverManager.registerDriver(d);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//URL格式：   协议<span class="comment">---IP---Port---DBNAME</span></span><br><span class="line">//Oracle      jdbc:oracle:thin:@192.168.1.100:1521:bjpowernode</span><br><span class="line">//Mysql       jdbc:mysql://192.168.1.100:3306/test</span><br><span class="line">String url = “jdbc:oracle:thin:@192.168.1.100:1521:bjpowernode”;</span><br><span class="line">String username = “scott”;</span><br><span class="line">String password = “tiger”;</span><br><span class="line">java.sql.Connection conn = DriverManager.getConnection(url,username,password);<span class="comment">--获取连接</span></span><br></pre></td></tr></table></figure><p>可将此sql数据装到配置文件中</p><blockquote><p>编写一个属性文件dbinfo.properties，文件内容如下：</p><p>driverClass=oracle.jdbc.driver.OracleDriver</p><p>url=jdbc:oracle:thin:@192.168.1.100:1521:bjpowernode</p><p>username=scott</p><p>password=tiger </p><p>如果要连接其他数据库则修改该属性文件即可。</p></blockquote><h5 id="获取数据库操作对象"><a href="#获取数据库操作对象" class="headerlink" title="获取数据库操作对象"></a>获取数据库操作对象</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br></pre></td></tr></table></figure><h5 id="执行sql语句"><a href="#执行sql语句" class="headerlink" title="执行sql语句"></a>执行sql语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = “<span class="keyword">DELETE</span> <span class="keyword">FROM</span> EMP_BAK <span class="keyword">WHERE</span> EMPNO=<span class="number">7369</span>”;</span><br><span class="line">stmt.executeUpdate(sql);  <span class="comment">--执行insert,update,delete (DML)</span></span><br><span class="line">String sql = “<span class="keyword">SELECT</span> ENAME,SAL <span class="keyword">FROM</span> EMP”;</span><br><span class="line">ResultSet  rs = stmt.executeQuery(sql);   <span class="comment">--执行查询语句(DQL)</span></span><br></pre></td></tr></table></figure><p>为防止sql注入, 创建一个对象  PreparedStatement</p><p>将sql语句预先编译  ps=conn.PreparedStatement(sql)</p><pre><code>rs=ps.executeXXX</code></pre><h5 id="有结果的-处理结果集"><a href="#有结果的-处理结果集" class="headerlink" title="有结果的,处理结果集"></a>有结果的,处理结果集</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(rs.next())&#123; //SELECT ENAME  AS  A,SAL  AS  B FROM EMP;</span><br><span class="line">  //通过查询结果的字段位置获取数据，获取为字符串类型</span><br><span class="line">  String ename = rs.getString(1);</span><br><span class="line">  //通过查询结果的字段位置获取数据，获取为指定类型</span><br><span class="line">  double sal = rs.getDouble(2);</span><br><span class="line">  //通过查询结果的字段名称获取数据（推荐），获取为字符串类型</span><br><span class="line">  String ename = rs.getString(“A”);</span><br><span class="line">  //通过查询结果的字段名称获取数据（推荐），获取为指定类型</span><br><span class="line">  double sal = rs.getDouble(“B”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//释放原则：从小到大依次释放，分别try…catch…</span><br><span class="line">finally&#123;</span><br><span class="line">  if(rs!=null)&#123;</span><br><span class="line">  try&#123;rs.close();&#125;catch(SQLException e)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">if(stmt!=null)&#123;</span><br><span class="line">  try&#123;stmt.close();&#125;catch(SQLException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(conn!=null)&#123;</span><br><span class="line">  try&#123;conn.close();&#125;catch(SQLException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jdbc事务处理"><a href="#jdbc事务处理" class="headerlink" title="jdbc事务处理"></a>jdbc事务处理</h4><ol><li><p>conn.setAutoCommit(false); //自动提交关闭</p></li><li><p>conn.commit(); //完整业务结束之后手动提交</p></li><li><p>conn.rollback(); //出现异常之后回滚</p></li></ol></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;JDBC–oracle数据库&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javaSE复习3</title>
    <link href="http://lvwi.github.io/2020/04/23/javaSE%E5%A4%8D%E4%B9%A03/"/>
    <id>http://lvwi.github.io/2020/04/23/javaSE%E5%A4%8D%E4%B9%A03/</id>
    <published>2020-04-23T11:44:22.000Z</published>
    <updated>2020-04-23T11:45:05.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>javaSE复习3</p><a id="more"></a><h3 id="java继承"><a href="#java继承" class="headerlink" title="java继承"></a>java继承</h3><p>继承需要符合的关系是：is-a，父类更通用，子类更具体</p><p>类用extends继承, 不能多继承, 可多重继承</p><p>接口用implements继承,可以多继承</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><blockquote><ul><li>子类拥有父类<strong>非</strong> private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul></blockquote><h4 id="super和this关键字"><a href="#super和this关键字" class="headerlink" title="super和this关键字"></a>super和this关键字</h4><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p><p>子类中调用父类的被重写方法时，要使用 super 关键字。</p><p>this关键字：指向自己的引用。</p><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器</p><p>在创建子类时,调用子类构造器时, 会先调用父类构造器</p><h3 id="java重写和重载"><a href="#java重写和重载" class="headerlink" title="java重写和重载"></a>java重写和重载</h3><h4 id="重写-override"><a href="#重写-override" class="headerlink" title="重写(override)"></a>重写(override)</h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写</strong></p><h5 id="方法重写规则"><a href="#方法重写规则" class="headerlink" title="方法重写规则"></a>方法重写规则</h5><blockquote><ul><li>参数列表必须完全与被重写方法的相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote><h4 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载(overload)"></a>重载(overload)</h4><h5 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则:"></a><strong>重载规则:</strong></h5><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><p>最主要的引用: 构造器的重载</p><h3 id="java多态"><a href="#java多态" class="headerlink" title="java多态"></a>java多态</h3><p>同一个行为具有多个不同表现形式或形态的能力</p><p>如F1按钮, 在不同app中的用法是不一样的</p><h4 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h4><ul><li>\1. 消除类型之间的耦合关系</li><li>\2. 可替换性</li><li>\3. 可扩充性</li><li>\4. 接口性</li><li>\5. 灵活性</li><li>\6. 简化性</li></ul><h4 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h4><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><h4 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h4><p>重写</p><p>接口</p><p>抽象类</p><h3 id="java-抽象类"><a href="#java-抽象类" class="headerlink" title="java 抽象类"></a>java 抽象类</h3><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用</p><p>abstract class来定义抽象类</p><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象方法只包含一个方法名，而没有方法体</p><p>有子类去具体描写该方法</p><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul><h3 id="java封装"><a href="#java封装" class="headerlink" title="java封装"></a>java封装</h3><p>指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法</p><h4 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h4><ul><li>\1. 良好的封装能够减少耦合。</li><li>\2. 类内部的结构可以自由修改。</li><li>\3. 可以对成员变量进行更精确的控制。</li><li>\4. 隐藏信息，实现细节</li></ul><p>要设置getter,setter方法</p><h3 id="java接口"><a href="#java接口" class="headerlink" title="java接口"></a>java接口</h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法</p><h4 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h4><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h4 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h4><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ul><li>\1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>\2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>\3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>\4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        &#x2F;&#x2F; 声明变量</span><br><span class="line">        &#x2F;&#x2F; 抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h4><p>没有任何方法的接口</p><h3 id="java包"><a href="#java包" class="headerlink" title="java包"></a>java包</h3><h4 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h4><ul><li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li><li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ul><h4 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h4><h2 id="java虚拟机编译运行的过程"><a href="#java虚拟机编译运行的过程" class="headerlink" title="java虚拟机编译运行的过程"></a>java虚拟机编译运行的过程</h2><p>new对象的时候</p><table><thead><tr><th></th><th>编译</th><th>运行</th></tr></thead><tbody><tr><td>new对象: Animal   dog= new dog(); 都有方法move()</td><td>检查参数的引用类型,运行dog.move()时, 编译检查Animal是有有相应方法</td><td>运行时，运行的是特定对象的方法 ,就是运行的Dog类中的move()</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;javaSE复习3&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javaSE复习2</title>
    <link href="http://lvwi.github.io/2020/04/23/javaSE%E5%A4%8D%E4%B9%A02/"/>
    <id>http://lvwi.github.io/2020/04/23/javaSE%E5%A4%8D%E4%B9%A02/</id>
    <published>2020-04-23T11:42:58.000Z</published>
    <updated>2020-04-23T11:44:07.570Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>javaSE复习2</p><a id="more"></a><h3 id="java数组"><a href="#java数组" class="headerlink" title="java数组"></a>java数组</h3><h4 id="声明数组-创建数组"><a href="#声明数组-创建数组" class="headerlink" title="声明数组,创建数组"></a>声明数组,创建数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double[] myList&#x3D;new double[10];         &#x2F;&#x2F; 首选的方法</span><br><span class="line">或</span><br><span class="line">double myList[];         &#x2F;&#x2F;  效果相同，但不是首选方法</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[][] typeName = <span class="keyword">new</span> type[typeLength1][typeLength2];</span><br></pre></td></tr></table></figure><h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>+++</p><h3 id="java时间日期"><a href="#java时间日期" class="headerlink" title="java时间日期"></a>java时间日期</h3><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>new Date(); 返回当前日期</p><p>new Date(long 毫秒数);返回毫秒数对应日期</p><h4 id="使用-SimpleDateFormat-格式化日期"><a href="#使用-SimpleDateFormat-格式化日期" class="headerlink" title="使用 SimpleDateFormat 格式化日期"></a>使用 SimpleDateFormat 格式化日期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">      Date dNow = <span class="keyword">new</span> Date( );</span><br><span class="line">      SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat (<span class="string">"yyyy-MM-dd hh:mm:ss"</span>); </span><br><span class="line">      System.out.println(<span class="string">"当前时间为: "</span> + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java-sleep-休眠"><a href="#java-sleep-休眠" class="headerlink" title="java  sleep 休眠"></a>java  sleep 休眠</h4><p>使当前线程暂停运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.sleep(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();<span class="comment">//默认是当前日期</span></span><br></pre></td></tr></table></figure><h4 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h4><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><hr><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>+++</p><h3 id="java方法"><a href="#java方法" class="headerlink" title="java方法"></a>java方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>创建另一个有相同名字但参数不同的方法</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法</p><p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p><p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarargsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用可变参数的方法</span></span><br><span class="line">        printMax(<span class="number">34</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">56.5</span>);</span><br><span class="line">        printMax(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">( <span class="keyword">double</span>... numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"No argument passed"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">double</span> result = numbers[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;  numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &gt;  result) &#123;</span><br><span class="line">                result = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"The max value is "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h4><p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p><p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p><p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p><p>finalize() 一般格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() &#123;   &#x2F;&#x2F; 在这里终结代码 &#125;</span><br></pre></td></tr></table></figure><h3 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h3><p>java.io中存在这些类</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>Java 的控制台输入由 System.in 完成</p><p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </span><br><span class="line">                      InputStreamReader(System.in));</span><br></pre></td></tr></table></figure><p>读取输入内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br.read()&#x2F;br.readLine()</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="comment">// 使用 System.in 创建 BufferedReader</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.println(<span class="string">"输入字符, 按下 'q' 键退出。"</span>);</span><br><span class="line">        <span class="comment">// 读取字符</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            c = (<span class="keyword">char</span>) br.read();</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125; <span class="keyword">while</span> (c != <span class="string">'q'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>控制台的输出由 print( ) 和 println() 完成</p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><table><thead><tr><th>IO流</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>字符流</td><td>reader</td><td>writer</td></tr><tr><td>字节流</td><td>inputStream</td><td>outputStream</td></tr><tr><td></td><td>具体实现各类</td><td>具体实现各类</td></tr></tbody></table><h5 id="两个重要的流"><a href="#两个重要的流" class="headerlink" title="两个重要的流"></a>两个重要的流</h5><h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/java/hello"</span>);<span class="comment">//方法一</span></span><br><span class="line"></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);<span class="comment">//方法二</span></span><br><span class="line">InputStream out = <span class="keyword">new</span> FileInputStream(f);</span><br></pre></td></tr></table></figure><h6 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h6><p>该类用来创建一个文件并向文件中写数据。</p><p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/java/hello"</span>)</span><br><span class="line"></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</span><br><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</span><br></pre></td></tr></table></figure><p>+++</p><h4 id="文件和IO"><a href="#文件和IO" class="headerlink" title="文件和IO"></a>文件和IO</h4><h5 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line"> </span><br><span class="line">public class CreateDir &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        String dirname &#x3D; &quot;&#x2F;tmp&#x2F;user&#x2F;java&#x2F;bin&quot;;</span><br><span class="line">        File d &#x3D; new File(dirname);</span><br><span class="line">        &#x2F;&#x2F; 现在创建目录</span><br><span class="line">        d.mkdirs();&#x2F;&#x2F;此路径所有文件夹都不存在时, 直接创建所有文件夹</span><br><span class="line">        &#x2F;&#x2F;d.mkdir();&#x2F;&#x2F;当&#x2F;tmp&#x2F;user&#x2F;java这些文件都存在时,创建bin文件夹</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h5><p>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。</p><p>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表</p><h5 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h5><p>删除文件可以使用 <strong>java.io.File.delete()</strong> 方法</p><h3 id="java-scanner类"><a href="#java-scanner类" class="headerlink" title="java scanner类"></a>java scanner类</h3><p>ava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 从键盘接收数据</span></span><br><span class="line">        <span class="comment">// next方式接收字符串</span></span><br><span class="line">        System.out.println(<span class="string">"next方式接收："</span>);</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext()) &#123;</span><br><span class="line">            String str1 = scan.next();</span><br><span class="line">            System.out.println(<span class="string">"输入的数据为："</span> + str1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// nextLine方式接收字符串</span></span><br><span class="line">        System.out.println(<span class="string">"nextLine方式接收："</span>);</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextLine()) &#123;</span><br><span class="line">            String str2 = scan.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"输入的数据为："</span> + str2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输出结果1</span><br><span class="line">next方式接收：</span><br><span class="line">runoob com</span><br><span class="line">输入的数据为：runoob</span><br><span class="line">输入结果2</span><br><span class="line">nextLine方式接收：</span><br><span class="line">runoob com</span><br><span class="line">输入的数据为：runoob com</span><br></pre></td></tr></table></figure><h3 id="java-异常处理"><a href="#java-异常处理" class="headerlink" title="java 异常处理"></a>java 异常处理</h3><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><ul><li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的</li></ul><h4 id="异常类的层次"><a href="#异常类的层次" class="headerlink" title="异常类的层次"></a>异常类的层次</h4><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p> Throwable 类的主要方法:</p><p><strong>getMessage()</strong>     <strong>getCause()</strong>   <strong>toString()</strong></p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>try{程度代码}  </p><p>catch(需要捕获的异常){catch代码}</p><p>finally{ finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。 }</p><h4 id="throw-thorws"><a href="#throw-thorws" class="headerlink" title="throw/thorws"></a>throw/thorws</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;javaSE复习2&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javaSE复习</title>
    <link href="http://lvwi.github.io/2020/04/23/javaSE%E5%A4%8D%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2020/04/23/javaSE%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-04-23T11:38:46.000Z</published>
    <updated>2020-04-23T11:40:39.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>javaSE复习-20190416</p><a id="more"></a><h3 id="java语言特性"><a href="#java语言特性" class="headerlink" title="java语言特性"></a>java语言特性</h3><ul><li>简单的</li><li>分布式的</li><li>面向对象的</li><li>多线程的</li><li>解释性语言</li><li>安全的</li><li>可移植的</li><li>高性能的</li><li>动态的</li></ul><h3 id="java环境配置"><a href="#java环境配置" class="headerlink" title="java环境配置"></a>java环境配置</h3><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ul><li>安装jdk</li><li>在 “系统变量” 中设置 3 项属性，JAVA_HOME： jdk的安装路径、PATH：<strong>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;*</strong>、CLASSPATH：%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;  (大小写无所谓)，使用 1.5 以上版本的 JDK，不用设置 CLASSPATH 环境变量</li></ul><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><h4 id="ide工具"><a href="#ide工具" class="headerlink" title="ide工具"></a>ide工具</h4><p>Eclipes</p><p>IDEA</p><p>Notepad+++</p><p>Netbeans</p><hr><h3 id="java基础语法"><a href="#java基础语法" class="headerlink" title="java基础语法"></a>java基础语法</h3><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p>​    每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>​    方法就是行为，一个类可以有很多方法</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>​    对象是类的一个实例，有状态和行为</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>​    类是一个模板，它描述一类对象的行为和状态</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li>大小写敏感</li><li>类名大写, 驼峰法</li><li>方法名小写, 如:count ; countNumber</li><li>原文件名与类名必须相同</li><li>主方法: public static void main(String[] args){ }</li></ol><h3 id="java对象和类"><a href="#java对象和类" class="headerlink" title="java对象和类"></a>java对象和类</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>多态</li><li>继承</li><li>封装</li><li>抽象</li><li>类☆</li><li>对象☆</li><li>实例</li><li>方法</li><li>重载</li></ul><h4 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h4><p>有具体状态和行为的一个实物, 如一条小白狗</p><h4 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h4><blockquote><p>概念:一类具有相同状态和行为的事务, 如狗; 就像一个模板</p></blockquote><blockquote><p>内容: </p><ul><li><p>变量 : 局部变量, 成员变量 , 类变量(静态变量)</p></li><li><p>方法</p></li><li><p>构造方法:  可显性写出构造方法,如无显性的系统会自动生成默认的,无参数的</p></li><li><p>构造方法的作用: 创建对象时需调用</p></li><li><p>构造方法可有多个, &gt;=1</p></li></ul></blockquote><blockquote><p>创建对象:  类名  对象名=new  类的构造方法; 如类 Dog     对象的创建: Dog  dog=new Dog();</p></blockquote><blockquote><p>通过对象调用变量和方法: 如上dog对象, 类Dog有变量 color, 方法 sleep(); </p><p>调用: dog.color; dog.sleep()</p></blockquote><blockquote><p>源文件声明:</p><ul><li>一个源文件中只能有一个public类</li><li>一个源文件中可以有多个非public类</li><li>文件名与public类名一致</li></ul></blockquote><h3 id="java-的基本数据类型"><a href="#java-的基本数据类型" class="headerlink" title="java 的基本数据类型"></a>java 的基本数据类型</h3><p>创建变量相当于申请内存来存储值</p><h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><p>六种数字类型（四个整数型，两个浮点型）</p><p>byte: [-2^7, 2^7-1] , 默认为0, 占8为</p><p>short : 占16位,默认为0</p><p>int  :32位,默认为0</p><p> long :64位, 默认为0L</p><p> float  :32位 ,默认为0.0F</p><p>double  :64位,默认为0.0d</p><p>一种字符类型，还有一种布尔型</p><p>char 单一的16位unicode字符,   如char a = ‘\u0001’;</p><p>boolean 1位  默认false</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>引用类型指向一个对象, 默认值为null</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>不能修改, 可用final修饰</p><p>final double  PI=3.1415926</p><p>最好大写</p><p>转义字符</p><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>低—&gt;高 可自动转换</p><p>高—&gt;低  要强制转换</p><h3 id="java变量类型"><a href="#java变量类型" class="headerlink" title="java变量类型"></a>java变量类型</h3><ul><li>类变量：独立于方法之外的变量，用 static 修饰。跟着类，不跟对象；储存在静态存储区，在第一次访问时被创建，在程序结束时被销毁。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。生命周期跟随对象一起；有默认值</li><li>局部变量：类的方法,构造方法, 代码块中的变量。栈上分配，必须要初始化</li></ul><h3 id="java修饰符"><a href="#java修饰符" class="headerlink" title="java修饰符"></a>java修饰符</h3><h4 id="访问类修饰符"><a href="#访问类修饰符" class="headerlink" title="访问类修饰符"></a>访问类修饰符</h4><ul><li><strong>default</strong> : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><p>请注意以下方法继承的规则：</p><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><h4 id="非访问类修饰符"><a href="#非访问类修饰符" class="headerlink" title="非访问类修饰符"></a>非访问类修饰符</h4><ul><li>static 修饰符，用来修饰类方法和类变量。</li><li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract 修饰符，用来创建抽象类和抽象方法。</li><li>synchronized 和 volatile 修饰符，主要用于线程的编程。</li></ul><h3 id="java运算符"><a href="#java运算符" class="headerlink" title="java运算符"></a>java运算符</h3><p>a++ 和++a的区别</p><p>++a : 先自增,再运算 b=5; b=2*++a; –&gt;b=12</p><p>a++:先运算,在自增 b=5;b=2*a++;–&gt;b=10</p><p>a–和–a的区别</p><p>同上</p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>把变量转化为二进制形式,进行 比较</p><p>如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0011</span> <span class="number">1100</span>   A=<span class="number">60</span></span><br><span class="line">B = <span class="number">0000</span> <span class="number">1101</span>   B=<span class="number">13</span></span><br><span class="line">(A&amp;B)=<span class="number">0000</span> <span class="number">1100</span></span><br><span class="line">（A | B）得到<span class="number">61</span>，即 <span class="number">0011</span> <span class="number">1101</span></span><br><span class="line">（A ^ B）得到<span class="number">49</span>，即 <span class="number">0011</span> <span class="number">0001</span>  对位值相同为<span class="number">0</span>, 否则为<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable x = (expression) ? value <span class="keyword">if</span> <span class="keyword">true</span> : value <span class="keyword">if</span> <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h4><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( Object reference variable ) <span class="keyword">instanceof</span>  (<span class="class"><span class="keyword">class</span>/<span class="title">interface</span> <span class="title">type</span>)</span></span><br><span class="line"><span class="class">    左边的类型</span>=右边的类型, 返回 <span class="keyword">true</span> , 否则<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="java循环语句"><a href="#java循环语句" class="headerlink" title="java循环语句"></a>java循环语句</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while(boolean表达式){</p><p>循环体</p><p>}</p><p>do{循环体}while(boolean表达式)</p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>for(初始化;boolean表达式;更新){</p><p>循环体</p><p>}</p><p>增强for循环</p><p>​    只要用于数组, 声明语句用于声明新的变量, 类型要与数组中数据一致</p><p>for(声明语句: 表达式){}</p><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p><p>break 跳出最里层的循环，并且继续执行该循环下面的语句</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代</p><h3 id="java条件语句"><a href="#java条件语句" class="headerlink" title="java条件语句"></a>java条件语句</h3><h4 id="if—else"><a href="#if—else" class="headerlink" title="if—else"></a>if—else</h4><p>if(…..){….}else{….}</p><h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><p>switch(expression)</p><p>{    case value :       //语句       break; //可选</p><p>​    case value :       //语句       break; //可选   </p><p> //你可以有任意数量的case语句    </p><p>default : //可选       //语句 }</p><p><strong>当匹配成功后, 没有break,后续语句都会执行**</strong></p><h3 id="number类和math类"><a href="#number类和math类" class="headerlink" title="number类和math类"></a>number类和math类</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>装箱; 拆箱</p><p>方法</p><h3 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h3><p>char的包装类</p><p>转义序列: \t   \n   \r  \b   \f</p><p>方法</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。</p><p>如果需要对字符串做很多修改，那么应该选择使用 <a href="https://www.runoob.com/java/java-stringbuffer.html">StringBuffer &amp; StringBuilder 类</a></p><p>方法: String.length();  长度    String.concat(string2)  连接字符串, 也可以用 string+string</p><p>创建格式化字符串 :静态方法 format() 返回一个String 对象</p><h3 id="StringBuffer类和StringBuilder类"><a href="#StringBuffer类和StringBuilder类" class="headerlink" title="StringBuffer类和StringBuilder类"></a>StringBuffer类和StringBuilder类</h3><p>当对字符串进行修改的时候用 ; 此类的对象可被多次修改且不创建新的对象</p><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问), 他的速度比较快</p><p>方法</p><p>append()</p></blockquote><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;javaSE复习-20190416&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据库初级学习</title>
    <link href="http://lvwi.github.io/2020/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E7%BA%A7%E5%AD%A6%E4%B9%A0/"/>
    <id>http://lvwi.github.io/2020/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E7%BA%A7%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-16T12:56:12.000Z</published>
    <updated>2020-04-16T12:58:23.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库学习-20200415"><a href="#数据库学习-20200415" class="headerlink" title="数据库学习-20200415"></a>数据库学习-20200415</h3><h4 id="plsql开发"><a href="#plsql开发" class="headerlink" title="plsql开发"></a>plsql开发</h4><h5 id="plsql块"><a href="#plsql块" class="headerlink" title="plsql块"></a>plsql块</h5><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">声明部分:DECLARE – 可选部分</span><br><span class="line">变量、常量、游标、用户定义异常声明;</span><br><span class="line">v_total_salNUMBER(9,2) :&#x3D; 0;---:&#x3D;是赋值运算符</span><br><span class="line">--简单变量</span><br><span class="line">--复合变量: TABLES: 类似数组</span><br><span class="line">语法 TYPE type_name IS TABLE OF scalar_datatype [NOT NULL] INDEX                           BY BINARY_INTEGER;</span><br><span class="line">                      identifiertype_name;</span><br><span class="line"></span><br><span class="line">    -- RECORDS:由多个组件组成的一种类型.包含一个或几个组件，每个组件称为一个域(FIELD);域的数据类型可以是简单变量类型、另一个RECORD类型或PL&#x2F;SQL的TABLE类型 </span><br><span class="line">--声明变量类型: %type 参照表中字段设置类型</span><br><span class="line">新变量   旧字段%type  </span><br><span class="line"></span><br><span class="line">执行体开始部分:BEGIN – 必要部分;</span><br><span class="line">SQL语句----被sql引擎处理.</span><br><span class="line">--SELECT select_list INTO ariable_name(查询的表的字段) | record_name(定义的变量)</span><br><span class="line">PL&#x2F;SQL语句----被pl&#x2F;sql引擎处理, 将sql语句传到sql引擎处理</span><br><span class="line">异常处理部分:EXCEPTION – 可选部分;</span><br><span class="line">程序出现异常时，捕捉异常并处理异常</span><br><span class="line">TOO_MANY_ROWS</span><br><span class="line">NO_DATA_FOUND</span><br><span class="line">执行体结束:END; – 必要部分</span><br></pre></td></tr></table></figure></div><p>plsql块可以嵌套</p><p>外面为父块, 不能获取子块的标识符</p><p>内部为子块,可以获取父块的标识符</p><h5 id="逻辑嵌套"><a href="#逻辑嵌套" class="headerlink" title="逻辑嵌套"></a>逻辑嵌套</h5><blockquote><p>逻辑语句: if</p></blockquote><blockquote><p>嵌套语句: </p><ul><li>使用简单循环重复要执行的语句<br>LOOP<br>statement1;<br>. . .<br>EXIT [WHEN condition];<br>END LOOP;<br>WHEN后面的条件语句就是确定是否退出循环的条件；当条件为TRUE是，退出循环。当条件为FALSE时，继续循环<br>必须使用EXIT语句退出循环，如果没有EXIT语句，将会无限循环下去</li><li>使用FOR循环，循环执行指定的次数<br>FOR index in [REVERSE]  –REVERSE是反转的意思，正常的循环计数器从小到大,使用REVERSE将使计数器从大到小递减<pre><code>lower_bound..upper_bound LOOP  </code></pre>statement1;<br>. . .<br>END LOOP;</li><li>使用WHILE 循环，只要条件满足就执行循环：<br>WHILE condition LOOP<br>statement1;<br>statement2;<br>. . .<br>END LOOP;</li></ul></blockquote><h5 id="sql游标"><a href="#sql游标" class="headerlink" title="sql游标"></a>sql游标</h5><p>游标是一段私有的SQL 工作区,也就是一段内存区域,用于暂时存放受SQL语句影响到的数据</p><p>隐式 显示</p><blockquote><p>游标属性包括四种，<br>%ROWCOUNT    受SQL影响的行数<br>%FOUND        Boolean 值，是否还有数据<br>%NOTFOUND     Boolean 值，是否已无数据<br>%ISOPEN        游标是否打开<br>显示游标和隐式游标都有这四种属性。但是使用方法和含义却不相同。<br>在使用游标的时候，需要使用游标名称作为前缀。但是隐式游标没有名称，所以在使用隐式游标的时候采取统一的一个名称SQL。<br>SQL%ROWCOUNT    受SQL影响的行数<br>SQL%FOUND        Boolean 值，是否还有数据<br>SQL%NOTFOUND                   Boolean 值，是否已无数据<br>SQL%ISOPEN        总是为FALSE</p></blockquote><blockquote><p>游标的作用</p><p>可以用于暂存查询取出的多行结果，然后一行一行的处理<br>显示游标就是专门用来查询多条数据的<br>按行处理查询返回的多行结果<br>显示游标首先将查询出的多行数据暂存在游标区域中,然后在PL/SQL中借助于循环语句手动的控制游标的多行操作,每次取出一条进行处理,直到取出游标中所有的数据为止</p></blockquote><blockquote><p>声明游标</p><p>DECLARE<br>CURSOR cursor_name IS<br>  select_statement;<br>begin  </p></blockquote><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>捕获异常: 在exception中捕获, 不往下传递</p><p>传播异常:未在exception中捕获, 异常会传播给调用环境</p><ul><li>语法</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION</span><br><span class="line">  WHEN exception1 [OR exception2 . . .] THEN</span><br><span class="line">    statement1;</span><br><span class="line">    . . .</span><br><span class="line">  [WHEN exception3 [OR exception4 . . .] THEN</span><br><span class="line">    statement1;</span><br><span class="line">    . . .]</span><br><span class="line">  [WHEN OTHERS THEN</span><br><span class="line">    statement1;</span><br><span class="line">    . . .]</span><br></pre></td></tr></table></figure></div><ul><li>异常的种类</li></ul><blockquote><p>预定义的oracle 数据库错误<br>非预定义的oracle 数据库错误<br>用户定义的错误</p><p><img src="./images/%E6%8D%95%E8%8E%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8.jpg" alt=""></p></blockquote><ul><li>异常捕获的相关函数</li></ul><p>在when others中,将报错赋值到以下两个代码中,并写到日志里 </p><p>SQLCODE 返回错误代码，NUMBER类型<br> SQLERRM  返回与错误代码关联的消息；VARCHAR2类型</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">V_CODE ERR_LOG.CODE%TYPE;   </span><br><span class="line">V_MESSAGE ERR_LOG.MESSAGE%TYPE;</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO TEST VALUES (1,&#39;AAA&#39;,3000);</span><br><span class="line">INSERT INTO TEST VALUES (1,NULL,NULL);   </span><br><span class="line">EXCEPTION</span><br><span class="line">WHEN OTHERS THEN </span><br><span class="line">V_CODE :&#x3D; SQLCODE;  </span><br><span class="line">V_MESSAGE :&#x3D; SQLERRM;   </span><br><span class="line">INSERT INTO ERR_LOG VALUES (V_CODE,V_MESSAGE);    </span><br><span class="line">COMMIT;</span><br><span class="line">DBMS_OUTPUT.put_line(&#39;发生异常&#39;);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div><h5 id="plsql的程序单元"><a href="#plsql的程序单元" class="headerlink" title="plsql的程序单元"></a>plsql的程序单元</h5><blockquote><p> PL/SQL程序,也叫PL/SQL程序单元,是数据库中命名的PL/SQL 块<br> 主要有四类：<br> 过程    执行特定操作<br> 函数    进行复杂计算,返回计算的结果<br> 包        将逻辑上相关的过程和函数组织在一起</p><p> ​        是由存储在一起的相关对象组成的PL/SQL存储程序组(是一组过程，函数，变量，常量的集合)    </p><p> 触发器    事件触发，执行相应操作</p></blockquote><p>过程: </p><p>用CREATE  OR REPLACE开始创建</p><p>name</p><p><img src="./images/plsql%E5%9D%97%E7%B1%BB%E5%9E%8B.jpg" alt=""></p><p>创建后用 exec调用</p><p>exec name</p><hr><p>触发器主要用于下列情况：</p><blockquote><p>安全性方面，确定用户的操作是否可以继续执行<br>产生对数据值修改的审计，将修改的信息记录下来，产生数据改动记录<br>提供更灵活的完整性校验规则，能根据复杂的规则校验数据<br>提供表数据的同步复制，使多个表的数据同步<br>事件日志记录，记录数据库的重要操作</p></blockquote><p>DML触发器<br> 系统触发器</p><p>启用或者禁用某个触发器<br>ALTER TRIGGER trigger_name  DISABLE | ENABLE</p><p>启用或者禁用某个对象上的所有触发器<br>ALTER TABLE table_name   DISABLE | ENABLE  ALL TRIGGERS</p><p>重编译触发器<br>ALTER TRIGGER trigger_name COMPILE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库学习-20200415&quot;&gt;&lt;a href=&quot;#数据库学习-20200415&quot; class=&quot;headerlink&quot; title=&quot;数据库学习-20200415&quot;&gt;&lt;/a&gt;数据库学习-20200415&lt;/h3&gt;&lt;h4 id=&quot;plsql开发&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>erp学习</title>
    <link href="http://lvwi.github.io/2020/04/14/erp%E5%AD%A6%E4%B9%A0-0/"/>
    <id>http://lvwi.github.io/2020/04/14/erp%E5%AD%A6%E4%B9%A0-0/</id>
    <published>2020-04-14T12:42:49.000Z</published>
    <updated>2020-04-14T12:43:10.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ERP学习"><a href="#ERP学习" class="headerlink" title="ERP学习"></a>ERP学习</h2><h3 id="plsql"><a href="#plsql" class="headerlink" title="plsql"></a>plsql</h3><ol><li><p>plsql连接oracle数据库</p><p>待补充</p><blockquote><p>报错:ORA-12425</p></blockquote></li><li><p>plsql快捷键</p><ul><li><p>输入完语句后, 点左上角齿轮执行(注:不选中需要执行的语句将,执行全部语句), 或者F8 快捷键</p></li><li><p>查询结果界面的绿色双箭头加横杠,可以显示全部的查询结果</p></li><li><p>ctrl+鼠标点击查询语句中的表名, 可以查看表结构</p></li><li><p>语句注释快捷键</p></li><li><p>对查询结果的各类操作(暂不需要)</p><ul><li>增删改: 在select语句中加 for update ,然后在表格中操作</li></ul></li></ul></li></ol><ul><li>点击查询结果表格的左上角,右击选择复制到excel中,可以导 </li></ul><p>包括空值的任何算术表达式都等于空<br>包括空值的连接表达式等于与空字符 串连接，也就是原来的字符串</p><p>字段别名用双引号</p><p>日期和字符型文本字符串必须用单引号扩起来</p><h4 id="sql函数"><a href="#sql函数" class="headerlink" title="sql函数"></a>sql函数</h4><p>单行函数</p><p>多行函数:</p><p>–分组函数 : 分组函省略列中的空值</p><p>在分组函数中使用NVL函数 , NVL函数迫使分组函数包括空值</p><p>COUNT函数是用于计算符合条件的数据的条数的。COUNT有两种用法：<br>    COUNT(<em>) 和 COUNT(字段)，并且结果可能不同。COUNT(</em>)求出所有符<br>   合条件的记录条数；而COUNT(字段)这是求出所有符合条件并且字段值是<br>   非空的记录数</p><p>Count(distinct(expr))返回不重复的，非空值的数量</p><p>不能在 WHERE 子句中出现组函数.</p><p>组函数可以出现在查询列表中，或者GROUP BY 子句中对组的过滤不能出现在WHERE子句中，而是要使用查询语句的另一个子句：HAVING 来补充where; 通过having进行组函数的过滤</p><p>组函数最多嵌套两层<br>如果使用组函数的查询没有GROUP BY 子句，那么组函数不能嵌套</p><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><h5 id="连接分类"><a href="#连接分类" class="headerlink" title="连接分类"></a>连接分类</h5><p>等值连接:用等号建立等值关系, 如:表1的字段1=表2的字段2</p><p>非等值连接:连接的关系可能是大于，小于，不等于或其他非等于的关系。非等值连接的操作符可以是：&gt; ,&lt;,&lt;&gt;,&gt;=,&lt;=,也可以是BETWEEN…AND,或者IN,LIKE</p><p>外连接</p><p>左外连接  where 表1.字段(+)=表2.字段, 表2的数据全部显示</p><p>右外链接</p><p>自连接</p><blockquote><blockquote><p>9i的新连接标准</p></blockquote></blockquote><p>where 表1 [xxx  join 表2]</p><p>xxx=以下的数据:</p><p>CROSS JOIN 表示产生交叉集合，也就是笛卡尔乘积的结果集合<br>NATURAL JOIN 表示自然连接 : 基于两个表中列名完全相同的一个或多个列产生等值连接</p><p>JOIN … USING(字段名)表示使用指定的字段作自然连接<br>INNER JOIN … ON (连接表达式)表示根据连接表达式构建多表连接<br>LEFT|RIGHT|FULL OUTER JOIN… ON (连接表达式)表示<br>     左/右/全外连接</p><p>在LEFT OUTER JOIN…ON(表达式) 表示左外连接，会返回所有左边表中的行，即使在右边的表中没有可对应的列值</p><h5 id="联合查询UNION"><a href="#联合查询UNION" class="headerlink" title="联合查询UNION"></a>联合查询UNION</h5><p>在数据库中，UNION和UNION ALL关键字都是将两个结果集合并为一个 .最常见的是过程表与历史表UNION </p><p>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DEPT </span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DEPT_D;</span><br></pre></td></tr></table></figure></div><p>而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DEPT </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DEPT_D</span><br></pre></td></tr></table></figure></div><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>为了给主查询（外部查询）提供数据而首先执行的查询（内部查询）称为子查询<br>子查询在主查询前执行一次<br>主查询使用子查询的结果</p><p>使用子查询的注意事项</p><pre><code>* 子查询要用括号括起来* 将子查询放在比较运算符的右边(增强可读性)* 在Oracle8i之前的版本中，子查询不能包含Order by子句* 只有在执行Top-N分析时，子查询中才需要使用Order by子句* 对单行子查询使用单行运算符* 对多行子查询使用多行运算符</code></pre><hr><h4 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h4><h5 id="事务的组成"><a href="#事务的组成" class="headerlink" title="事务的组成"></a>事务的组成</h5><p>Oracle数据库的事务由下列语句组成：<br>一组DML语句，修改的数据在他们中保持一致<br>一个 DDL (Data Define Language) 语句<br>一个 DCL (Data Control Language)语句</p><h5 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h5><p>事务处理的ACID特性<br>   Atomic:原子性,                            Consistent:一致性,<br>   Isolated:隔离性,                           Durable:永久性 </p><p>++++</p><h4 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h4><table><thead><tr><th>对象名称</th><th>描述</th></tr></thead><tbody><tr><td>表</td><td>基本的数据存储对象，以行和列的形式存在</td></tr><tr><td>约束</td><td>执行数据校验，保证数据完整性的对象;约束是在表上强制执行的数据校验规则</td></tr><tr><td>视图</td><td>一个或多个表数据的显示</td></tr><tr><td>索引</td><td>用于提高查询的速度</td></tr><tr><td>同义词</td><td>表的别名</td></tr></tbody></table><h5 id="删除表数据"><a href="#删除表数据" class="headerlink" title="删除表数据"></a>删除表数据</h5><ul><li><p>在删除数据的时候，可以使用DELETE语句，但是效率不高。可以使用TRUNCATE命令来删除数据</p></li><li><p>TRUNCATE TABLE 语句</p><blockquote><p>清除表中所有的记录<br>是DDL语句，不可以回滚，而DELETE语句可以ROLLBACK<br>释放表的存储空间,DELETE命令不释放空间</p></blockquote></li><li><p>是删除数据的方法之一</p></li><li><p>语法：TRUNCATE TABLE table_name;</p><pre><code>TRUNCATE TABLE DEPT_BACK;</code></pre></li></ul><p>++++</p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><ul><li>表中所有数据将被删除</li><li>没有完成的事务被提交</li><li>所有相关的索引被删除</li><li>不能回退</li><li>语法：DROP TABLE table_name;<pre><code>DROP TABLE DEPT_BACK;</code></pre></li></ul><h3 id="oracle数据库"><a href="#oracle数据库" class="headerlink" title="oracle数据库"></a>oracle数据库</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><blockquote><p>用户所涉及的数据库结构: 由一个或多个表空间,数据库模式对象</p><p>表空间包含多个数据文件</p><p>必有SYSTEM表空间</p><p>段: 数据段, 索引段,回滚段,临时段</p><p>块–&gt;区—&gt;段—&gt;表空间</p></blockquote><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><blockquote><p>由操作系统文件决定: 数据文件,日志文件,控制文件</p></blockquote><h4 id="模式和模式对象"><a href="#模式和模式对象" class="headerlink" title="模式和模式对象"></a>模式和模式对象</h4><blockquote><p>表, 视图,索引,聚集,程序单元:储存过程,函数和包</p></blockquote><h4 id="数据库权限"><a href="#数据库权限" class="headerlink" title="数据库权限"></a>数据库权限</h4><p> 用户权限: 系统权限, 对象权限</p><blockquote><ul><li><p>关键字</p><ul><li>候选关键字</li><li>主键 </li><li>外键  表a ,表b , 公共关键字为 键1, 而1又是a的主键, 那么1就是b的外键</li><li>公共关键字      </li></ul></li><li><p>范式</p><ul><li>第一范式: 无重复的列</li><li>第二范式:主键作为唯一区别,其他属性完全依赖主键</li><li>第三范式:每个非主属性都不传递依赖于关系模型的候选键</li></ul></li></ul></blockquote><blockquote><p>表格中弹性域存在的意义: 备用字段</p><p>? 若备用字段不足如何添加</p></blockquote><blockquote></blockquote><h3 id="oracle-server"><a href="#oracle-server" class="headerlink" title="oracle  server"></a>oracle  server</h3><p>一个运行着的数据库就是oracle server , 是由db+instance(实例)组成的</p><h4 id="oracle实例"><a href="#oracle实例" class="headerlink" title="oracle实例"></a>oracle实例</h4><blockquote><p>实例的组成: 由分配的内存区+多个后台进程</p><p>​                    内存区: 启动数据库是被分配的系统全局区的一个内存区</p><p>实例的作用: 管理数据库的数据, 是存取和控制数据库的软件机制</p></blockquote><h4 id="oracle进程"><a href="#oracle进程" class="headerlink" title="oracle进程"></a>oracle进程</h4><blockquote><p>用户进程–用户用客户端的sql工具连接数据库</p><p>服务器进程–处理连接到该实例的用户进程</p><p>后台进程–多进程系统中的附加进程    (DBWR,LGWR,CKPT,SMON,PMON,ARCH,RECO)</p><ul><li>DBWR:将缓冲区写入数据文件, 使缓冲区变为未使用状态</li><li>LGWR:将日志缓冲区写入磁盘上的一个日志文件</li><li>CKPT:当该进程被唤醒执行时, 对全部数据文件的标题进行修改,指示该检查点,并通知DBWR将脏数据块写入数据文件</li><li>…</li></ul></blockquote><h4 id="oracle内存结构"><a href="#oracle内存结构" class="headerlink" title="oracle内存结构"></a>oracle内存结构</h4><blockquote><p>软件代码区: 储存正在执行或可执行的程序代码</p><p>系统全局区,包括数据缓冲储存区,日志缓冲区,共享池 : </p><p>程序全局区,包括栈区和数据区</p><p>排序区</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ERP学习&quot;&gt;&lt;a href=&quot;#ERP学习&quot; class=&quot;headerlink&quot; title=&quot;ERP学习&quot;&gt;&lt;/a&gt;ERP学习&lt;/h2&gt;&lt;h3 id=&quot;plsql&quot;&gt;&lt;a href=&quot;#plsql&quot; class=&quot;headerlink&quot; title=&quot;pls
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
