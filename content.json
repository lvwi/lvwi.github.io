{"pages":[{"title":"","text":"个人简介 学而不思则罔，思而不学则殆 博客信息本站推荐索引 博客主题相关 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享","link":"/about/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"申请友链须知 - 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 - 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 - 申请请提供：站点名称、站点链接、站点描述、**logo或头像**（`不要设置防盗链`）。 - 排名不分先后，刷新后重排，更新信息后请留言告知。 - 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 - 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 - 本站友链信息如下，申请友链前请先添加本站信息： 网站名称：时遇诺 网站地址：https://lvww.top 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"留下你的脚印吧 畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"2019的最后一天","text":"概述 今天很开心 明年要更好 今天很开心1234public class HelloWorld{ } 明年要更好","link":"/2019/12/30/2019%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"},{"title":"JDBC--oracle数据库","text":"摘要JDBC–oracle数据库 接口JDBC的本质是一套规范一套接口，是SUN定义的J2EE规范之一。 所有的java程序员面向JDBC接口调用，所有的数据库厂商程序员面向JDBC规范实现。 实现类被称作“驱动”。驱动以jar结尾 jar包: 最初的方式:在classpath 中配置 ​ CLASSPATH= ;E:\\oracle\\product\\10.2.0\\db_1\\jdbc\\lib\\ojdbc14.jar JDBC编程六步曲注册驱动方式1 12java.sql.Driver driver = new oracle.jdbc.driver.OracleDriver(); 创建驱动对象java.sql.DriverManager.registerDriver(driver);--注册驱动 方式2 123456789Class.forName(“oracle.jdbc.driver.OracleDriver”);原理：package oracle.jdbc.driver;public class OracleDriver{ static{ Driver d = new OracleDriver(); DriverManager.registerDriver(d); }} 获取数据库连接1234567//URL格式： 协议---IP---Port---DBNAME//Oracle jdbc:oracle:thin:@192.168.1.100:1521:bjpowernode//Mysql jdbc:mysql://192.168.1.100:3306/testString url = “jdbc:oracle:thin:@192.168.1.100:1521:bjpowernode”;String username = “scott”;String password = “tiger”;java.sql.Connection conn = DriverManager.getConnection(url,username,password);--获取连接 可将此sql数据装到配置文件中 编写一个属性文件dbinfo.properties，文件内容如下： driverClass=oracle.jdbc.driver.OracleDriver url=jdbc:oracle:thin:@192.168.1.100:1521:bjpowernode username=scott password=tiger 如果要连接其他数据库则修改该属性文件即可。 获取数据库操作对象1Statement stmt = conn.createStatement(); 执行sql语句1234String sql = “DELETE FROM EMP_BAK WHERE EMPNO=7369”;stmt.executeUpdate(sql); --执行insert,update,delete (DML)String sql = “SELECT ENAME,SAL FROM EMP”;ResultSet rs = stmt.executeQuery(sql); --执行查询语句(DQL) 为防止sql注入, 创建一个对象 PreparedStatement 将sql语句预先编译 ps=conn.PreparedStatement(sql) rs=ps.executeXXX有结果的,处理结果集12345678910while(rs.next()){ //SELECT ENAME AS A,SAL AS B FROM EMP; //通过查询结果的字段位置获取数据，获取为字符串类型 String ename = rs.getString(1); //通过查询结果的字段位置获取数据，获取为指定类型 double sal = rs.getDouble(2); //通过查询结果的字段名称获取数据（推荐），获取为字符串类型 String ename = rs.getString(“A”); //通过查询结果的字段名称获取数据（推荐），获取为指定类型 double sal = rs.getDouble(“B”);} 释放资源123456789101112//释放原则：从小到大依次释放，分别try…catch…finally{ if(rs!=null){ try{rs.close();}catch(SQLException e){} }if(stmt!=null){ try{stmt.close();}catch(SQLException e){}}if(conn!=null){ try{conn.close();}catch(SQLException e){}}} jdbc事务处理 conn.setAutoCommit(false); //自动提交关闭 conn.commit(); //完整业务结束之后手动提交 conn.rollback(); //出现异常之后回滚 参考文章:参考链接","link":"/2020/04/23/JDBC-oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"2019年最后的学习","text":"摘要 学习markdown hello world标题我是一级标题 我是二级标题 段落的换行是两个以上空格加回车第二段 第三段 字体我是斜体文字—-在需要斜体的文字上加 双*号 我是斜体文字 2—-在需要斜体的文字上加 双_号 我是粗体文字—–在需要粗体的文字上加双**号 __同等 我是粗斜体文字 —-加双***号 分隔线一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格 删除线在需要显示删除的文字两端加~~即可 我是被删除了 下划线通过html的标签来实现 我带下划线哟 脚注[^ 要注明的文字] 例子: 鼠标悬浮脚注, 就可以显示第二句话 我是脚注[^第一次学习脚注] [^第一次学习脚注]: 2019年最后一天, 学习markdown的语法 markdown列表支持无序及有序列表 无序可用 * + - 做标记 有序 第一项 第二个 列表嵌套 第一项 第一项的第一个元素 第一项的第二个元素 第二项 第二项的第一个元素 dddd markdown区块用 &gt; 符号,然后紧跟一个空格 区块引用 20191231 学习markdown 区块嵌套, 第一个用&gt; 第二层用&gt;&gt; 第三层用&gt;&gt;&gt; 第一层 第二层 第三层 markdown代码段落上的一个函数或片段的代码可以用(`)包起来 printf()函数 代码区块使用4个空格或者一个制表符(tab键),或者用(```)包裹 &lt;div&gt;这是一个div&lt;/div&gt;123456javascript: $(document).ready( function)(){ alert('Markdown');}); markdown 链接([链接名称])(链接地址) 或者&lt;链接地址&gt; 注:使用时, 去掉 第一个() 这是一个链接 qdx的博客 https://www.qiudx.top 高级链接链接也可以用变量代替,文档末尾附带变量地址: 例: [Google] ([1]) 此时用1作为变量, 使用时去掉[1]外面的() [Google][1] 文档末尾注明: [1]: http://google.com/ +++ Markdown图片格式如下: ![alt 属性文本] (图片地址) ![alt 属性文本] (图片地址 &quot;可选标题&quot;) 图片地址也可以是网址 , 链接可以如上使用变量例子: Markdown表格制作表格用|来分隔不同的单元格, 用-分隔表头和其他行 格式: |表头 | 表头 | |----- | -----| |单元格|单元格|例子: |表头|表头| |----|----| |单元格|单元格|??? 表格格式使用不成功 快捷键 ctrl+t Markdown高级技巧支持html元素可使用 等 例如: Ctrl 加粗 倾斜 我是 ==高亮== 转义Markdown 使用反斜杠转义特殊字符 ** 公式插入数学公式, 使用两个$$包裹Tex或者LaTeX格式的数学公式来实现.提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：$$\\mathbf(v)_1\\times\\mathbf(v)_2= \\begin{vmatrix}\\mathbf(i) &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$ 学习用md语言花流程图 graph LR 横向流程图源代码格式(这个是mermaid语言, 要用引用代码的方式 ```来处理) 12345graph LR A[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] graph TD 竖向流程图 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 3、标准流程图源码格式： 1&lt;div id=&quot;flowchart-0&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt; 4、标准流程图源码格式（横向）： 1&lt;div id=&quot;flowchart-1&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt; 5、UML时序图源码样例： 12345678```sequence对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？``` 1234567891011121314151617 **6、UML时序图源码复杂样例：** ~~~sequence ```sequence Title: 标题：复杂使用 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象B-&gt;小三: 你好吗 小三--&gt;&gt;对象A: 对象B找我了 对象A-&gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 ``` 7、UML标准时序图样例： 1234567891011121314```mermaid%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好!``` 8、甘特图样例： 123456789101112131415161718192021```mermaid%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h``` 快捷键typora 快捷键 无序列表:输入-之后输入空格 有序列表:输入数字+“.”之后输入空格 任务列表:-[空格]空格 文字 标题:ctrl+数字 表格:ctrl+t 生成目录:[TOC]按回车 选中一整行:ctrl+l 选中单词:ctrl+d 选中相同格式的文字:ctrl+e 跳转到文章开头:ctrl+home 跳转到文章结尾:ctrl+end 搜索:ctrl+f 替换:ctrl+h 引用:输入&gt;之后输入空格 代码块:ctrl+alt+f 加粗:ctrl+b 倾斜:ctrl+i 下划线:ctrl+u 删除线:alt+shift+5 插入图片:直接拖动到指定位置即可或者ctrl+shift+i 插入链接:ctrl+k About Typora–关于 Typora Preferences–偏好(设置)–⌘， Check for Updates–检查更新 Services–服务 Hide Typora–隐藏 Typora–⌘H Hide Other–隐藏 Other–⌥⌘H Show All–显示全部 Quit Typora–退出 Typora–⌘Q File–文件 New–新建–⌘N Open..–打开 .–⌘O Open Recent–打开最近 Open Quickly…–快速打开–⇧⌘O Open File Location–打开文件位置 Close–关闭–⌘W Save…–保存–⌘S Duplicate–另存为–⇧⌘S Rename–重命名 Move To…–移动到 Revert To–恢复 Export–输出 Page Setup…–页面设置–⇧⌘P Print…–打印–⌘P Edit–编辑 Undo–撤消–⌘Z Redo–重做–⌘Y Cut–剪切–⌘X Copy–复制–⌘C Paste–黏贴–⌘V Delete–删除 Copy As Markdown–另存为Markdown–⇧⌘C Copy As HTML Code–另存为超链接代码–⌥⌘C Paste As Plain Text–另存为纯文本–⇧⌘V Select All–全选–⌘A Select Line/Sentence–选择行/句子–⌘L Select Styled Scope–选择段落–⌘E Select Word–选定单词–⌘D Jump To–跳到…() Math Tools–数学工具 Image Tools–图片工具 Find–寻找 Spelling and Grammar–拼写和语法 Substitutions–替换 Speech–语音 Start Dictation…–开始听写 Emoji &amp; Symbosls–表情 &amp; 符号–⌃⌘Space Paragraph–段落 Heading 1–标题1–⌘1 Heading 2–标题2–⌘2 Heading 3–标题3–⌘3 Heading 4–标题4–⌘4 Heading 5–标题5–⌘5 Paragraph–段落–⌘0 Table–表格–⌘T Code Fences–代码栏–⌥⌘C Math Block–数字块–⌥⌘B Quote–引用–⌥⌘Q Ordered List–顺序列表–⌥⌘O Unordered List–无序列表–⌥⌘U Task List–任务列表–⌥⌘X List Indentation–列表缩进 Link Reference–参考链接–⌥⌘L Footnotes–脚注–⌥⌘R Horizontal Line–水平线–⇧⌘- Table of Contents–目录 YAML Front Matter Format–格式 Strong–粗体–⌘B Emphasis–重点(倾斜)–⌘I Underline–下划线–⌘U Code–代码–⇧⌘` Strike–中划线–⌃~ Comment–评论 Hyperlink–超链接–⌘K Image–图片–⌥⌘I Clear Format–清除格式–⌘\\ View–查看 Source Code Mode–源代码模式–⌘/ Focus Mode–聚焦模式–⇧⌘R Typewriter Mode–打字机模式 Toggle Outine Panel–面板切换–⇧⌘B Always On Top–总是在上面 Full Screen–全屏–⌃⌘F Window–窗口 Minimize–最小化–⌘M Zoom–变焦(伪全屏) st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框(是或否?) sub1=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st->op->cond cond(yes)->io->e cond(no)->sub1(right)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options); st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框(是或否?) sub1=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st(right)->op(right)->cond cond(yes)->io(bottom)->e cond(no)->sub1(right)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);","link":"/2020/01/01/2019%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"20200107微信小程序新建表格,并添加点击数据跳转页面功能","text":"微信小程序新建表格,并添加点击数据跳转页面功能一 . 新建表格 在wxss的页面中添加如下样式,样式数据可自行调整 12345678910111213141516171819202122232425262728293031.table { border: 0px solid black; width: 100%;}.tr { display: flex; width: 100%; justify-content: center; height: 3rem; align-items: center;}.td { width:40%; justify-content: center; text-align: center;}.bg-w{ background: snow;}.bg-g{ background: #E6F3F9;}.th { width: 40%; justify-content: center; background: #3366FF; color: #fff; display: flex; height: 3rem; align-items: center;} 在js页面中添加数据列表 123456789101112data: { list:[ {\"code\":\"1\",\"j\":\"第一章\",\"c\":\"第一章\"}, {\"code\":\"2\",\"j\":\"第二章\",\"c\":\"第二章\"}, {\"code\":\"3\",\"j\":\"第三章\",\"c\":\"第三章\"}, {\"code\":\"4\",\"j\":\"第四章\",\"c\":\"第四章\"}, {\"code\":\"5\",\"j\":\"第五章\",\"c\":\"第五章\"}, {\"code\":\"6\",\"j\":\"第六章\",\"c\":\"第六章\"}, {\"code\":\"7\",\"j\":\"第七章\",\"c\":\"第七章\"}, {\"code\":\"8\",\"j\":\"第八章\",\"c\":\"第八章\"}, ]} 在wxml文件下新增表格 12345678910111213141516171819&lt;view class=\"table\"&gt; &lt;view class=\"tr bg-w\"&gt; &lt;view class=\"th\"&gt;表头1&lt;/view&gt; &lt;view class=\"th\"&gt;表头2&lt;/view&gt; &lt;view class=\"th\"&gt;表头3&lt;/view&gt; &lt;/view&gt; &lt;block wx:for=\"{{list}}\" wx:key=\"{{code}}\" &gt; &lt;view class=\"tr bg-g\" wx:if=\"{{index % 2 == 0}}\"&gt; &lt;view class=\"td\"&gt;{{item.code}}&lt;/view&gt; &lt;view class=\"td\" bindtap=\"btn{{item.code}}\"&gt;{{item.j}}&lt;/view&gt; &lt;view class=\"td\"&gt;{{item.c}}&lt;/view&gt; &lt;/view&gt; &lt;view class=\"tr\" wx:else&gt; &lt;view class=\"td\"&gt;{{item.code}}&lt;/view&gt; &lt;view class=\"td\" bindtap=\"btn{{item.code}}\"&gt;{{item.j}}&lt;/view&gt; &lt;view class=\"td\"&gt;{{item.c}}&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; 以上内容参考:https://blog.csdn.net/benben0729/article/details/81567967 二 表格中点击数据跳转在上述第3点的wxml代码中有如下代码 12&lt;view class=\"td\" bindtap=\"btn{{item.code}}\"&gt;{{item.j}}&lt;/view&gt;bindtap=\"btn{{item.code}}\" 这段内容就是跳转所需要的代码 是在js中取的对应的数据,然后在js中编写如下跳转代码 12345btn2: function (e) { wx.navigateTo({ url: '../study-2/study-2', }) }, 当然,目前我还未解决如何在点击的时候传递数据到后台, 使得js中的跳转代码也能够一步到位,不需要过多重复 未完待续…","link":"/2020/01/07/20200107%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%B0%E5%BB%BA%E8%A1%A8%E6%A0%BC-%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E6%95%B0%E6%8D%AE%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E5%8A%9F%E8%83%BD/"},{"title":"erp学习","text":"ERP学习plsql plsql连接oracle数据库 待补充 报错:ORA-12425 plsql快捷键 输入完语句后, 点左上角齿轮执行(注:不选中需要执行的语句将,执行全部语句), 或者F8 快捷键 查询结果界面的绿色双箭头加横杠,可以显示全部的查询结果 ctrl+鼠标点击查询语句中的表名, 可以查看表结构 语句注释快捷键 对查询结果的各类操作(暂不需要) 增删改: 在select语句中加 for update ,然后在表格中操作 点击查询结果表格的左上角,右击选择复制到excel中,可以导 包括空值的任何算术表达式都等于空包括空值的连接表达式等于与空字符 串连接，也就是原来的字符串 字段别名用双引号 日期和字符型文本字符串必须用单引号扩起来 sql函数单行函数 多行函数: –分组函数 : 分组函省略列中的空值 在分组函数中使用NVL函数 , NVL函数迫使分组函数包括空值 COUNT函数是用于计算符合条件的数据的条数的。COUNT有两种用法： COUNT() 和 COUNT(字段)，并且结果可能不同。COUNT()求出所有符 合条件的记录条数；而COUNT(字段)这是求出所有符合条件并且字段值是 非空的记录数 Count(distinct(expr))返回不重复的，非空值的数量 不能在 WHERE 子句中出现组函数. 组函数可以出现在查询列表中，或者GROUP BY 子句中对组的过滤不能出现在WHERE子句中，而是要使用查询语句的另一个子句：HAVING 来补充where; 通过having进行组函数的过滤 组函数最多嵌套两层如果使用组函数的查询没有GROUP BY 子句，那么组函数不能嵌套 多表查询连接分类等值连接:用等号建立等值关系, 如:表1的字段1=表2的字段2 非等值连接:连接的关系可能是大于，小于，不等于或其他非等于的关系。非等值连接的操作符可以是：&gt; ,&lt;,&lt;&gt;,&gt;=,&lt;=,也可以是BETWEEN…AND,或者IN,LIKE 外连接 左外连接 where 表1.字段(+)=表2.字段, 表2的数据全部显示 右外链接 自连接 9i的新连接标准 where 表1 [xxx join 表2] xxx=以下的数据: CROSS JOIN 表示产生交叉集合，也就是笛卡尔乘积的结果集合NATURAL JOIN 表示自然连接 : 基于两个表中列名完全相同的一个或多个列产生等值连接 JOIN … USING(字段名)表示使用指定的字段作自然连接INNER JOIN … ON (连接表达式)表示根据连接表达式构建多表连接LEFT|RIGHT|FULL OUTER JOIN… ON (连接表达式)表示 左/右/全外连接 在LEFT OUTER JOIN…ON(表达式) 表示左外连接，会返回所有左边表中的行，即使在右边的表中没有可对应的列值 联合查询UNION在数据库中，UNION和UNION ALL关键字都是将两个结果集合并为一个 .最常见的是过程表与历史表UNION UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。 123SELECT * FROM DEPT UNION SELECT * FROM DEPT_D; 而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了 123SELECT * FROM DEPT UNION ALLSELECT * FROM DEPT_D 子查询为了给主查询（外部查询）提供数据而首先执行的查询（内部查询）称为子查询子查询在主查询前执行一次主查询使用子查询的结果 使用子查询的注意事项 * 子查询要用括号括起来 * 将子查询放在比较运算符的右边(增强可读性) * 在Oracle8i之前的版本中，子查询不能包含Order by子句 * 只有在执行Top-N分析时，子查询中才需要使用Order by子句 * 对单行子查询使用单行运算符 * 对多行子查询使用多行运算符 数据库的事务事务的组成Oracle数据库的事务由下列语句组成：一组DML语句，修改的数据在他们中保持一致一个 DDL (Data Define Language) 语句一个 DCL (Data Control Language)语句 事务的特性事务处理的ACID特性 Atomic:原子性, Consistent:一致性, Isolated:隔离性, Durable:永久性 ++++ 数据库对象 对象名称 描述 表 基本的数据存储对象，以行和列的形式存在 约束 执行数据校验，保证数据完整性的对象;约束是在表上强制执行的数据校验规则 视图 一个或多个表数据的显示 索引 用于提高查询的速度 同义词 表的别名 删除表数据 在删除数据的时候，可以使用DELETE语句，但是效率不高。可以使用TRUNCATE命令来删除数据 TRUNCATE TABLE 语句 清除表中所有的记录是DDL语句，不可以回滚，而DELETE语句可以ROLLBACK释放表的存储空间,DELETE命令不释放空间 是删除数据的方法之一 语法：TRUNCATE TABLE table_name; TRUNCATE TABLE DEPT_BACK; ++++ 删除表 表中所有数据将被删除 没有完成的事务被提交 所有相关的索引被删除 不能回退 语法：DROP TABLE table_name;DROP TABLE DEPT_BACK; oracle数据库逻辑结构 用户所涉及的数据库结构: 由一个或多个表空间,数据库模式对象 表空间包含多个数据文件 必有SYSTEM表空间 段: 数据段, 索引段,回滚段,临时段 块–&gt;区—&gt;段—&gt;表空间 物理结构 由操作系统文件决定: 数据文件,日志文件,控制文件 模式和模式对象 表, 视图,索引,聚集,程序单元:储存过程,函数和包 数据库权限 用户权限: 系统权限, 对象权限 关键字 候选关键字 主键 外键 表a ,表b , 公共关键字为 键1, 而1又是a的主键, 那么1就是b的外键 公共关键字 范式 第一范式: 无重复的列 第二范式:主键作为唯一区别,其他属性完全依赖主键 第三范式:每个非主属性都不传递依赖于关系模型的候选键 表格中弹性域存在的意义: 备用字段 ? 若备用字段不足如何添加 oracle server一个运行着的数据库就是oracle server , 是由db+instance(实例)组成的 oracle实例 实例的组成: 由分配的内存区+多个后台进程 ​ 内存区: 启动数据库是被分配的系统全局区的一个内存区 实例的作用: 管理数据库的数据, 是存取和控制数据库的软件机制 oracle进程 用户进程–用户用客户端的sql工具连接数据库 服务器进程–处理连接到该实例的用户进程 后台进程–多进程系统中的附加进程 (DBWR,LGWR,CKPT,SMON,PMON,ARCH,RECO) DBWR:将缓冲区写入数据文件, 使缓冲区变为未使用状态 LGWR:将日志缓冲区写入磁盘上的一个日志文件 CKPT:当该进程被唤醒执行时, 对全部数据文件的标题进行修改,指示该检查点,并通知DBWR将脏数据块写入数据文件 … oracle内存结构 软件代码区: 储存正在执行或可执行的程序代码 系统全局区,包括数据缓冲储存区,日志缓冲区,共享池 : 程序全局区,包括栈区和数据区 排序区","link":"/2020/04/14/erp%E5%AD%A6%E4%B9%A0-0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/12/30/hello-world/"},{"title":"javaSE复习","text":"摘要javaSE复习-20190416 java语言特性 简单的 分布式的 面向对象的 多线程的 解释性语言 安全的 可移植的 高性能的 动态的 java环境配置windows 安装jdk 在 “系统变量” 中设置 3 项属性，JAVA_HOME： jdk的安装路径、PATH：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;*、CLASSPATH：%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; (大小写无所谓)，使用 1.5 以上版本的 JDK，不用设置 CLASSPATH 环境变量 linuxide工具Eclipes IDEA Notepad+++ Netbeans java基础语法实例变量​ 每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 方法​ 方法就是行为，一个类可以有很多方法 对象​ 对象是类的一个实例，有状态和行为 类​ 类是一个模板，它描述一类对象的行为和状态 基本语法 大小写敏感 类名大写, 驼峰法 方法名小写, 如:count ; countNumber 原文件名与类名必须相同 主方法: public static void main(String[] args){ } java对象和类基本概念 多态 继承 封装 抽象 类☆ 对象☆ 实例 方法 重载 对象有具体状态和行为的一个实物, 如一条小白狗 类 概念:一类具有相同状态和行为的事务, 如狗; 就像一个模板 内容: 变量 : 局部变量, 成员变量 , 类变量(静态变量) 方法 构造方法: 可显性写出构造方法,如无显性的系统会自动生成默认的,无参数的 构造方法的作用: 创建对象时需调用 构造方法可有多个, &gt;=1 创建对象: 类名 对象名=new 类的构造方法; 如类 Dog 对象的创建: Dog dog=new Dog(); 通过对象调用变量和方法: 如上dog对象, 类Dog有变量 color, 方法 sleep(); 调用: dog.color; dog.sleep() 源文件声明: 一个源文件中只能有一个public类 一个源文件中可以有多个非public类 文件名与public类名一致 java 的基本数据类型创建变量相当于申请内存来存储值 内置数据类型六种数字类型（四个整数型，两个浮点型） byte: [-2^7, 2^7-1] , 默认为0, 占8为 short : 占16位,默认为0 int :32位,默认为0 long :64位, 默认为0L float :32位 ,默认为0.0F double :64位,默认为0.0d 一种字符类型，还有一种布尔型 char 单一的16位unicode字符, 如char a = ‘\\u0001’; boolean 1位 默认false 引用数据类型引用类型指向一个对象, 默认值为null 常量不能修改, 可用final修饰 final double PI=3.1415926 最好大写 转义字符 自动类型转换低—&gt;高 可自动转换 高—&gt;低 要强制转换 java变量类型 类变量：独立于方法之外的变量，用 static 修饰。跟着类，不跟对象；储存在静态存储区，在第一次访问时被创建，在程序结束时被销毁。 实例变量：独立于方法之外的变量，不过没有 static 修饰。生命周期跟随对象一起；有默认值 局部变量：类的方法,构造方法, 代码块中的变量。栈上分配，必须要初始化 java修饰符访问类修饰符 default : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 请注意以下方法继承的规则： 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问类修饰符 static 修饰符，用来修饰类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 java运算符a++ 和++a的区别 ++a : 先自增,再运算 b=5; b=2*++a; –&gt;b=12 a++:先运算,在自增 b=5;b=2*a++;–&gt;b=10 a–和–a的区别 同上 位运算符把变量转化为二进制形式,进行 比较 如 12345A = 0011 1100 A=60B = 0000 1101 B=13(A&amp;B)=0000 1100（A | B）得到61，即 0011 1101（A ^ B）得到49，即 0011 0001 对位值相同为0, 否则为1 三元运算符1variable x = (expression) ? value if true : value if false instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型） 12( Object reference variable ) instanceof (class/interface type) 左边的类型=右边的类型, 返回 true , 否则false java循环语句whilewhile(boolean表达式){ 循环体 } do{循环体}while(boolean表达式) forfor(初始化;boolean表达式;更新){ 循环体 } 增强for循环 ​ 只要用于数组, 声明语句用于声明新的变量, 类型要与数组中数据一致 for(声明语句: 表达式){} breakbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句 continuecontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代 java条件语句if—elseif(…..){….}else{….} switch case判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 switch(expression) { case value : //语句 break; //可选 ​ case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } 当匹配成功后, 没有break,后续语句都会执行** number类和math类包装类装箱; 拆箱 方法 Character类char的包装类 转义序列: \\t \\n \\r \\b \\f 方法 String类String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类 方法: String.length(); 长度 String.concat(string2) 连接字符串, 也可以用 string+string 创建格式化字符串 :静态方法 format() 返回一个String 对象 StringBuffer类和StringBuilder类当对字符串进行修改的时候用 ; 此类的对象可被多次修改且不创建新的对象 两者区别StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问), 他的速度比较快 方法 append() 参考文章:参考链接","link":"/2020/04/23/javaSE%E5%A4%8D%E4%B9%A0/"},{"title":"javaSE复习2","text":"摘要javaSE复习2 java数组声明数组,创建数组123double[] myList=new double[10]; // 首选的方法或double myList[]; // 效果相同，但不是首选方法 多维数组1type[][] typeName = new type[typeLength1][typeLength2]; Arrays类+++ java时间日期Date类new Date(); 返回当前日期 new Date(long 毫秒数);返回毫秒数对应日期 使用 SimpleDateFormat 格式化日期123456789import java.util.*;import java.text.*;public class DateDemo { public static void main(String args[]) { Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\"); System.out.println(\"当前时间为: \" + ft.format(dNow)); }} java sleep 休眠使当前线程暂停运行 1thread.sleep(3000) Calendar类Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建 1Calendar c = Calendar.getInstance();//默认是当前日期 GregorianCalendar类Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。 正则表达式+++ java方法123456修饰符 返回值类型 方法名(参数类型 参数名){ ... 方法体 ... return 返回值;} 方法的重载创建另一个有相同名字但参数不同的方法 可变参数JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。 12345678910111213141516171819202122public class VarargsDemo { public static void main(String args[]) { // 调用可变参数的方法 printMax(34, 3, 3, 2, 56.5); printMax(new double[]{1, 2, 3}); } public static void printMax( double... numbers) { if (numbers.length == 0) { System.out.println(\"No argument passed\"); return; } double result = numbers[0]; for (int i = 1; i &lt; numbers.length; i++){ if (numbers[i] &gt; result) { result = numbers[i]; } } System.out.println(\"The max value is \" + result); }} finalize()方法Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。 例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。 在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。 finalize() 一般格式是： 1protected void finalize() { // 在这里终结代码 } Java 流(Stream)、文件(File)和IOjava.io中存在这些类 输入Java 的控制台输入由 System.in 完成 为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。 12BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 读取输入内容 1br.read()/br.readLine() 例子123456789101112131415import java.io.*; public class BRRead { public static void main(String args[]) throws IOException { char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"输入字符, 按下 'q' 键退出。\"); // 读取字符 do { c = (char) br.read(); System.out.println(c); } while (c != 'q'); }} 输出控制台的输出由 print( ) 和 println() 完成 读取文件 IO流 输入 输出 字符流 reader writer 字节流 inputStream outputStream 具体实现各类 具体实现各类 两个重要的流FileInputStream该流用于从文件读取数据，它的对象可以用关键字 new 来创建 1234InputStream f = new FileInputStream(\"C:/java/hello\");//方法一File f = new File(\"C:/java/hello\");//方法二InputStream out = new FileInputStream(f); FileOutputStream该类用来创建一个文件并向文件中写数据。 如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件 1234OutputStream f = new FileOutputStream(\"C:/java/hello\")File f = new File(\"C:/java/hello\");OutputStream f = new FileOutputStream(f); +++ 文件和IO创建文件夹1234567891011import java.io.File; public class CreateDir { public static void main(String args[]) { String dirname = &quot;/tmp/user/java/bin&quot;; File d = new File(dirname); // 现在创建目录 d.mkdirs();//此路径所有文件夹都不存在时, 直接创建所有文件夹 //d.mkdir();//当/tmp/user/java这些文件都存在时,创建bin文件夹 }} 读取目录如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。 可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表 删除目录删除文件可以使用 java.io.File.delete() 方法 java scanner类ava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入 1Scanner s = new Scanner(System.in); 12345678910111213141516171819202122232425import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if (scan.hasNext()) { String str1 = scan.next(); System.out.println(\"输入的数据为：\" + str1); } // nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if (scan.hasNextLine()) { String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\" + str2); } scan.close(); }} 12345678输出结果1next方式接收：runoob com输入的数据为：runoob输入结果2nextLine方式接收：runoob com输入的数据为：runoob com java 异常处理要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的 异常类的层次所有的异常类是从 java.lang.Exception 类继承的子类。 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。 方法 Throwable 类的主要方法: getMessage() getCause() toString() 捕获异常try{程度代码} catch(需要捕获的异常){catch代码} finally{ finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 } throw/thorws12345678910import java.io.*;public class className{ public void deposit(double amount) throws RemoteException { // Method implementation throw new RemoteException(); } //Remainder of class definition} 参考文章:参考链接","link":"/2020/04/23/javaSE%E5%A4%8D%E4%B9%A02/"},{"title":"学习如何更换blog的主题","text":"2020年1月4号 学习如何更换blog的主题第一步 找到喜欢的主题 使用命令 $ git clone 主题的地址 ，注意主题要clone到blog文件夹中的themes文件夹内 第二步 修改配置文件并安装 git克隆完成后，打开本地blog下的“_config.yml”配置文件（非主题文件下） 找到theme配置选项, 将theme选项配置为新下载的主题（“：”冒号之后空格不可少 空格后为新下载的主题名） 第三步 修改主题配置文件 打开新主题路径下的”_config.yml”,按照主题作者要求进行相关配置 第四步 调试主题,发布 根据自己的需要,修改主题的部分信息 $ hexo server --debug可以在blog文件夹下,使用上述语句,进行调试 调试无误后,即可发布到自己的blog上啦 $ hexo g -d进行发布 备注在修改主题配置文件的时候发现的问题","link":"/2020/01/04/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2blog%E7%9A%84%E4%B8%BB%E9%A2%98/"},{"title":"javaSE复习3","text":"摘要javaSE复习3 java继承继承需要符合的关系是：is-a，父类更通用，子类更具体 类用extends继承, 不能多继承, 可多重继承 接口用implements继承,可以多继承 特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承， 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 super和this关键字super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 子类中调用父类的被重写方法时，要使用 super 关键字。 this关键字：指向自己的引用。 final关键字final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 构造器子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器 在创建子类时,调用子类构造器时, 会先调用父类构造器 java重写和重载重写(override)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写 方法重写规则 参数列表必须完全与被重写方法的相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 重载(overload)重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 最主要的引用: 构造器的重载 java多态同一个行为具有多个不同表现形式或形态的能力 如F1按钮, 在不同app中的用法是不一样的 多态的优点 \\1. 消除类型之间的耦合关系 \\2. 可替换性 \\3. 可扩充性 \\4. 接口性 \\5. 灵活性 \\6. 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 多态的实现方式重写 接口 抽象类 java 抽象类由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用 abstract class来定义抽象类 抽象方法抽象方法只包含一个方法名，而没有方法体 有子类去具体描写该方法 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 java封装指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法 封装的优点 \\1. 良好的封装能够减少耦合。 \\2. 类内部的结构可以自由修改。 \\3. 可以对成员变量进行更精确的控制。 \\4. 隐藏信息，实现细节 要设置getter,setter方法 java接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 \\1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 \\2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 \\3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 \\4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 语法1234[可见度] interface 接口名称 [extends 其他的接口名] { // 声明变量 // 抽象方法} 标记接口没有任何方法的接口 java包包的作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 import 关键字java虚拟机编译运行的过程new对象的时候 编译 运行 new对象: Animal dog= new dog(); 都有方法move() 检查参数的引用类型,运行dog.move()时, 编译检查Animal是有有相应方法 运行时，运行的是特定对象的方法 ,就是运行的Dog类中的move() 参考文章:参考链接","link":"/2020/04/23/javaSE%E5%A4%8D%E4%B9%A03/"},{"title":"数据库初级学习","text":"数据库学习-20200415plsql开发plsql块123456789101112131415161718192021声明部分:DECLARE – 可选部分变量、常量、游标、用户定义异常声明; v_total_sal NUMBER(9,2) := 0;---:=是赋值运算符 --简单变量 --复合变量: TABLES: 类似数组 语法 TYPE type_name IS TABLE OF scalar_datatype [NOT NULL] INDEX BY BINARY_INTEGER; identifier type_name; -- RECORDS:由多个组件组成的一种类型.包含一个或几个组件，每个组件称为一个域(FIELD);域的数据类型可以是简单变量类型、另一个RECORD类型或PL/SQL的TABLE类型 --声明变量类型: %type 参照表中字段设置类型 新变量 旧字段%type 执行体开始部分:BEGIN – 必要部分; SQL语句----被sql引擎处理. --SELECT select_list INTO ariable_name(查询的表的字段) | record_name(定义的变量) PL/SQL语句----被pl/sql引擎处理, 将sql语句传到sql引擎处理异常处理部分:EXCEPTION – 可选部分;程序出现异常时，捕捉异常并处理异常TOO_MANY_ROWSNO_DATA_FOUND执行体结束:END; – 必要部分 plsql块可以嵌套 外面为父块, 不能获取子块的标识符 内部为子块,可以获取父块的标识符 逻辑嵌套 逻辑语句: if 嵌套语句: 使用简单循环重复要执行的语句LOOPstatement1;. . .EXIT [WHEN condition];END LOOP;WHEN后面的条件语句就是确定是否退出循环的条件；当条件为TRUE是，退出循环。当条件为FALSE时，继续循环必须使用EXIT语句退出循环，如果没有EXIT语句，将会无限循环下去 使用FOR循环，循环执行指定的次数FOR index in [REVERSE] –REVERSE是反转的意思，正常的循环计数器从小到大,使用REVERSE将使计数器从大到小递减lower_bound..upper_bound LOOP statement1;. . .END LOOP; 使用WHILE 循环，只要条件满足就执行循环：WHILE condition LOOPstatement1;statement2;. . .END LOOP; sql游标游标是一段私有的SQL 工作区,也就是一段内存区域,用于暂时存放受SQL语句影响到的数据 隐式 显示 游标属性包括四种，%ROWCOUNT 受SQL影响的行数%FOUND Boolean 值，是否还有数据%NOTFOUND Boolean 值，是否已无数据%ISOPEN 游标是否打开显示游标和隐式游标都有这四种属性。但是使用方法和含义却不相同。在使用游标的时候，需要使用游标名称作为前缀。但是隐式游标没有名称，所以在使用隐式游标的时候采取统一的一个名称SQL。SQL%ROWCOUNT 受SQL影响的行数SQL%FOUND Boolean 值，是否还有数据SQL%NOTFOUND Boolean 值，是否已无数据SQL%ISOPEN 总是为FALSE 游标的作用 可以用于暂存查询取出的多行结果，然后一行一行的处理显示游标就是专门用来查询多条数据的按行处理查询返回的多行结果显示游标首先将查询出的多行数据暂存在游标区域中,然后在PL/SQL中借助于循环语句手动的控制游标的多行操作,每次取出一条进行处理,直到取出游标中所有的数据为止 声明游标 DECLARECURSOR cursor_name IS select_statement;begin 异常处理捕获异常: 在exception中捕获, 不往下传递 传播异常:未在exception中捕获, 异常会传播给调用环境 语法 12345678910EXCEPTION WHEN exception1 [OR exception2 . . .] THEN statement1; . . . [WHEN exception3 [OR exception4 . . .] THEN statement1; . . .] [WHEN OTHERS THEN statement1; . . .] 异常的种类 预定义的oracle 数据库错误非预定义的oracle 数据库错误用户定义的错误 异常捕获的相关函数 在when others中,将报错赋值到以下两个代码中,并写到日志里 SQLCODE 返回错误代码，NUMBER类型 SQLERRM 返回与错误代码关联的消息；VARCHAR2类型 1234567891011121314DECLAREV_CODE ERR_LOG.CODE%TYPE; V_MESSAGE ERR_LOG.MESSAGE%TYPE;BEGININSERT INTO TEST VALUES (1,'AAA',3000);INSERT INTO TEST VALUES (1,NULL,NULL); EXCEPTIONWHEN OTHERS THEN V_CODE := SQLCODE; V_MESSAGE := SQLERRM; INSERT INTO ERR_LOG VALUES (V_CODE,V_MESSAGE); COMMIT;DBMS_OUTPUT.put_line('发生异常');END; plsql的程序单元 PL/SQL程序,也叫PL/SQL程序单元,是数据库中命名的PL/SQL 块 主要有四类： 过程 执行特定操作 函数 进行复杂计算,返回计算的结果 包 将逻辑上相关的过程和函数组织在一起 ​ 是由存储在一起的相关对象组成的PL/SQL存储程序组(是一组过程，函数，变量，常量的集合) 触发器 事件触发，执行相应操作 过程: 用CREATE OR REPLACE开始创建 name 创建后用 exec调用 exec name 触发器主要用于下列情况： 安全性方面，确定用户的操作是否可以继续执行产生对数据值修改的审计，将修改的信息记录下来，产生数据改动记录提供更灵活的完整性校验规则，能根据复杂的规则校验数据提供表数据的同步复制，使多个表的数据同步事件日志记录，记录数据库的重要操作 DML触发器 系统触发器 启用或者禁用某个触发器ALTER TRIGGER trigger_name DISABLE | ENABLE 启用或者禁用某个对象上的所有触发器ALTER TABLE table_name DISABLE | ENABLE ALL TRIGGERS 重编译触发器ALTER TRIGGER trigger_name COMPILE","link":"/2020/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E7%BA%A7%E5%AD%A6%E4%B9%A0/"},{"title":"hexo主题创建学习","text":"hexo主题创建学习-20200119一. 创建blog&gt; 1. hexo是什么 &gt; &gt; Hexo 是一款能将Markdown文件编译成html 静态文件，可以提供 Web服务，做Blog，使其能部署到github等等 &gt; &gt; 因为hexo正常情况下不需要部署到服务器, 服务器上保存的时候markdown写的文章,以及hexo生成的html页面 &gt; &gt; 所以hexo是个静态页面生成、上传的工具 &gt; &gt; 2. 因为hexo基于node.js制作的, 所以要安装node.js &gt; &gt; 3. 安装hexo ``` $ sudo npm install -g hexo-cli``` sudo为了给root权限,读取系统配置文件 &gt; &gt; 4. 测试是否安装完成 ```$ hexo -v``` &gt; &gt; 5. 新建blog &gt; &gt; 123$ mkdir ./hexo-blog$ cd ./hexo-blog$ hexo init &gt; &gt; 6. 启动blog ```$ hexo s``` &gt; &gt; 7. 主题下载二. 主题开发1. 创建博客-myblog2. blog的目录1234567891011myblog ➔ tree -L 1.├── _config.yml // 总体的配置文件---可以修改themes名称├── node_modules // NodeJs 所依赖的包，后期也可以自己添加插件├── package-lock.json // 支持 hexo 运行的 NodeJs 包├── package.json // 自定义的 NodeJs 包├── scaffolds // Hexo Markdown 加载时的关键字，如data,title等,它会在启动的时候默认加载├── source // md 源文件目录├── public // 在运行语句 hexo generade 自动生成html格式的静态文件组└── themes // 主题文件夹 └── landscape // 默认主题 3. 创建主题mythemes目录结构如下 1234567891011└── themes ├── landscape └── mythemes // 自建的主题目录 ├── _config.yml // 主题配置文件 ├── layout // 主要构造 html 的模板 │ ├── index.ejs // 主页模板 │ ├── layout.ejs // 布局模板 │ └── post.ejs // md 编译成 html 后的文件模板 └── source // 静态资源文件目录 ├── css // css 样式目录 └── js // JavaScript 脚本目录 4. 模板介绍(1) . 3个ejs模板layout.ejs —添加内容可以在blog中默认显示 123添加语句 让idnex.ejs和post.ejs内容显示 &lt;%- include(&quot;index.ejs&quot;) %&gt; &lt;%- include(&quot;post.ejs&quot;) %&gt; index.ejs–不默认显示 post.ejs–不默认显示 (2). EJS 标签简介​ 简介, 详见ejs学习 标签 含义 &lt;% %&gt; 脚本标签，用于流程控制, 不会显示 &lt;%_ 删除前面的空格符 &lt;%= 输出数据到模板 &lt;%- 输出非转义数据到模板 &lt;%# 注释 &lt;%% 输出字符串『&lt;%』 &gt;% 脚本结束标签 -%&gt; 结束时，删除换行符 _%&gt; 结束时，删除空格符 &lt;%- include(“index.ejs”) %&gt; 引入其他模板 (3). hexo变量hexo-api, 根据它提供的变量api获取页面信息,进行blog开发 变量 描述 site 总体变量，几乎都是从这里开始的 site.posts 所有文章 site.posts[0].path 文章路径，带日期的 site.posts[0].slug 文章路径，根据项目文件夹的路径来的 site.posts[0]._id 文章的唯一 id，后面会用于 active 对比 site.posts[0].title 文章的标题 site.posts[0].date 文章的时间 page.date 在直接访问文章路径下，文章的时间 page.title 在直接访问文章路径下，文章的标题 page._id 在直接访问文章路径下，文章的的唯一 id，后面会用于 active 对比 page.content 引入对应文章的正文 config.xxx 总体配置文件的引用 _config.yml theme.xxx 主题配置文件 theme._config.yml &lt;%- body %&gt; 同时引入 post.ejs 和 index.ejs &lt;%- css(path, …) %&gt; 引入 css 文件 &lt;%- js(path, …) %&gt; 引入 js 文件 语句的简单应用layout.ejs 1234567891011121314151617181920212223242526272829303132333435&gt;&lt;!DOCTYPE html&gt; &lt;html&gt;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; 这里是 layout.ejs &lt;%- include(&quot;index.ejs&quot;) %&gt; &lt;%- include(&quot;post.ejs&quot;) %&gt; &lt;!-- 一般在写逻辑的时候会用到这个标签，这个标签不会输出到页面上 --&gt; &lt;% %&gt; &lt;!-- 这个标签会输出到页面上，是带着非转义符号的 --&gt; &lt;% var test = &quot;基本上，就用这两组标签，其他的也用不上。&quot;; %&gt; &lt;%- test %&gt; &lt;br /&gt; &lt;% site.posts.forEach(function(post){ %&gt; &lt;%- post.path %&gt; &lt;br /&gt; &lt;%- post.slug %&gt; &lt;br /&gt; &lt;%- post._id %&gt; &lt;br /&gt; &lt;%- post.title %&gt; &lt;br /&gt; &lt;%- post.date %&gt; &lt;br /&gt; &lt;a href=&quot;/&lt;%- post.path %&gt;&quot;&gt;&lt;%- post.title %&gt;&lt;/a&gt; &lt;% }); %&gt; ![](https://img2018.cnblogs.com/blog/626593/201906/626593-20190620152507609-296007299.png) &lt;%- body %&gt; &lt;/body&gt; &lt;/html&gt; 输出页面 三 .主题制作1. 布局—以我想要的效果为例 2. 文件结构新建静态资源文件，并且放一下测试的 md 文件进 _posts 中。主要添加了 theme.mythemes.source 中的静态资源和布局用的 ejs 1234567891011121314151617181920212223242526272829303132├── _config.yml...├── source│ └── _posts│ └── test-hello-world.md └── about └── archives└── themes ├── landscape └── mythemes ├── _config.yml ├── layout │ ├── asideleft.ejs // 用于左侧边栏 │ ├── index.ejs // 用于主页 │ ├── layout.ejs // 用于布局 │ ├── nav.ejs // 用于导航 | ├── asideright.ejs // 用于右侧边栏 │ └── post.ejs // 用于文章 └── source ├── css │ └── main.css ├── js │ └── main.js └── lib //想要有树状结构的侧边栏，给目录、文件、以及搜索框增加图标，需要外部的图片库 └── font-awesome // 下载好的文字图片库 ├── css ├── fonts ├── less └── scss └── highlight └── jquery-3.4.1.min.js └── jquery.pjax.js 3. 文件配置需添加的内容(1)主题配置文件theme._config.yml 12345678title: 遇见你是最美好的时刻author: 时遇menus: 主页: / 关于: /about 分类: /archiveslinks: github: https://github.com (2)主布局文件 layout.ejs1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;%- theme.title %&gt;&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 引入配置文件 --&gt; &lt;%- css('css/main.css') %&gt; &lt;!-- 字体图片库 --&gt; &lt;%- css('lib/font-awesome/css/font-awesome.min.css') %&gt; &lt;!-- 代码高亮库 --&gt; &lt;%- css('/lib/highlight/styles/下载的主题') %&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;!-- 引入侧边栏 --&gt; &lt;!-- 左右侧边栏的问题 利用div的清除浮动: float:left 实现 --&gt; &lt;aside id=&quot;#aside&quot;&gt; &lt;%- include('aside.ejs') %&gt; &lt;/aside&gt; &lt;!-- 引入导航 --&gt; &lt;nav&gt; &lt;%- include('nav.ejs') %&gt; &lt;/nav&gt; &lt;!-- 引入正文 --&gt; &lt;div id=&quot;content&quot;&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 引入 jquery --&gt; &lt;%- js('/lib/jquery-3.4.1.min.js') %&gt; &lt;!-- 引入 pjax --&gt; &lt;%- js('/lib/jquery.pjax.js') %&gt; &lt;!-- 引入 js 文件 --&gt; &lt;%- js('js/main.js') %&gt; &lt;!-- 引入代码高亮的 js 这里是加载 --&gt; &lt;%- js('/lib/highlight/highlight.pack.js') %&gt; &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; (3)css样式- main.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362/*#####全局样式######*/* { margin: 0; padding: 0; border: 0;}html, body { height: 100%;}asidel { width: 300px; height: 100%; position: fixed; background: #262a30;}asider { width: 300px; height: 100%; position: fixed; background: #262a30;}nav { height: 50px; background: #b9e1b1;}#content { height: 100%; padding-left: 300px; background: #f9f7ed;}/*#####全局样式######*//* ##### 导航 ########## */nav #menu { float: right; padding-right: 20px;}nav ul li { float: left; padding: 10px; list-style: none;}nav ul li a{ color: #555; font-size: 12px; text-decoration: none;}nav ul li a:hover { border-bottom: 1px solid;}/* #################### 导航 #################### *//* #################### 侧边栏 #################### *//* 搜索框 */aside input { width: 290px; height: 50px; margin: 0; border: 0; padding: 0; left: 0; font-size: 14px; background: #131417; text-indent: 20px; outline: none; color: #87daff; position: absolute;}/* 搜索图标 */aside #search i.fa.fa-search { position: absolute; top: 0; right: 0; color: #757575; font-size: 20px; width: 40px; height: 50px; background: #131417; text-align: center; line-height: 2.5;}/* 滚动条 */aside { overflow-y: scroll;}/* 树目录位置 */aside #tree { padding-top: 55px}/* 树目录 */aside ul { padding: 0px 5px 5px 20px;}aside ul li { list-style: none; line-height: 25px;}aside ul li a { color: #999; font-size: 14px; text-decoration: none}aside ul li a:hover { color: #ccc; border-bottom: 1px solid #ccc; cursor:pointer;}aside #tree .active a,aside #tree .active a:hover { color: #87daff; border-bottom: 1px solid #87daff;}aside #tree i.fa { padding-right: 5px;}/* #################### 侧边栏 #################### *//* #################### 文章 #################### *//* 作者 时间 相关 */#post-author { font-size: 9px; position: absolute; top: 60px; right: 30px; color: #999;}#post-date { font-size: 9px; position: absolute; top: 80px; right: 30px; color: #999;}/* 文章各个元素间隔 */#article { padding: 30px;}#article * { margin: 30px 0;}#article h1,#article h2,#article h3,#article h4,#article h5,#article h6 { line-height: 40px; margin: 20px 0 15px;}#article h1 { font-size: 32px; font-weight: 900; padding-bottom: 10px; border-bottom: 2px solid #e06c75;}#article h2 { font-size: 25px; border-left: 3px solid #73b1e0; padding-left: 10px;}#article h3 { font-size: 22px}#article a { color: #e06c75; text-decoration: none;}#article a:hover { border-bottom: 1px solid;}#article h1 a:hover{ border-bottom: none;}#article code { border-radius: 3px; box-shadow: 0px 0px 5px #999;}#article img { max-width: 100%; height: auto; border-radius: 5px; box-shadow: 0px 0px 8px #999;}#article pre { font-size: 14px; margin: 20px 0 15px;}#article p { margin: 0 0 10px; line-height: 30px}/* 表格处理 */#article table { width: 100%; border: 0; margin: 20px 0 50px 0; border-collapse: collapse; border-spacing: 0; line-height: 35px; border-radius: 8px; box-shadow: 0px 0px 5px #999;}#article table th { background: #73b1e0; font-weight: 800; font-size: 18px; text-align: left; line-height: 35px; color: #FFF;}#article table tr:nth-child(odd) { background: #F4F4F4;}#article table tr:hover,#article table td:hover { background: #badbf5; color: #FFF;}#article table td, table th { padding: 5px 20px 5px 20px}#article table tr:first-child th:first-child { border-top-left-radius: 3px;}#article table tr:first-child th:last-child { border-top-right-radius: 3px;}#article table tr:last-child td:first-child { border-bottom-left-radius: 3px;}#article table tr:last-child td:last-child { border-bottom-right-radius: 3px;}/* #################### 文章 #################### *//* #################### 主页 #################### */#articleList { position: absolute;}#articleList .article-li { margin: 20px; height: 200px; border-radius: 5px; box-shadow: 1px 1px 8px #999; list-style: none; border: 1px solid #999;}#articleList .article-digest * { word-wrap: break-word; display: inline; font-size: 12px; color: #555; text-decoration: none; cursor:auto; border-radius: none; box-shadow: none;}#articleList .article-digest{ padding: 30px; position: relative; top: 35px; width: 85%;}#articleList .article-date{ position: relative; background: #e06c75; color: #f9f7ed; padding: 10px; top: -5px; border-radius: 2px; margin-left: 30px;}#articleList .article-read { position: absolute; background: #e06c75; color: #f9f7ed; padding: 10px; border-radius: 2px; right: 15px; margin-top: 140px; text-decoration: none; z-index: 1;}#articleList .article-title { position: relative; color: #555; text-decoration: none; font-size: 24px; font-weight: bold; top: 50px; right: 110px;}/* #################### 主页 #################### *//* #################### 自适应 #################### */@media screen and (max-width: 800px) { aside { display: none; } #content { padding-left: 0; } canvas#live2dcanvas { display: none; }}/*竖屏*/@media all and (orientation : portrait) { aside { display: none; } #content { padding-left: 0; } canvas#live2dcanvas { display: none; }}/* #################### 自适应 #################### */ (4) 添加导航栏 nav.ejs1234567891011121314&lt;ul id=&quot;menu&quot;&gt; &lt;!-- 内部链接本页面直接跳转 --&gt; &lt;% for ( menu in theme.menus ) { %&gt; &lt;li class=&quot;menu-item&quot;&gt; &lt;a href=&quot;&lt;%- theme.menus[menu] %&gt;&quot; class=&quot;menu-item-link&quot;&gt;&lt;%- menu %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% } %&gt; &lt;!-- 外部链接打开新的窗口跳转 --&gt; &lt;% for ( link in theme.links ) { %&gt; &lt;li class=&quot;menu-item&quot;&gt; &lt;a href=&quot;&lt;%- theme.links[link] %&gt;&quot; class=&quot;menu-item-link&quot; target=&quot;_blank&quot;&gt;&lt;%- link %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% } %&gt;&lt;/ul&gt; (5)侧边栏 aside.ejs树状结构的侧边栏所需的图片库 Font Awesome ,语句见主题配置文件 laout.ejs中引用新增字体图片库的css文件 语句见layout.ejs文件添加内容 在 main.css 文件中，增加侧边栏美化 adide.ejs —-主要做了路径转树的算法，然后显示树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!-- 侧边目录栏 --&gt;&lt;div id=&quot;tree&quot;&gt; &lt;% &lt;!-- 将路径转换成 tree 目录结构 --&gt; const pathToTree = (input) =&gt; { var output = []; input.forEach(function(post){ &lt;!-- 用来分割去掉时间的路径 --&gt; var chain = post.slug.split(&quot;/&quot;); var currentNode = output; for (var j = 0; j &lt; chain.length; j++) { if (chain[j] === '') { break; } var wantedNode = chain[j]; var lastNode = currentNode; for (var k = 0; k &lt; currentNode.length; k++) { if (currentNode[k].title == wantedNode) { currentNode = currentNode[k].children; break; } } if (lastNode == currentNode) { var newNode = currentNode[k] = { post: post, title: wantedNode, children: [] }; currentNode = newNode.children; } else { delete currentNode.children } } }); return output; } &lt;!-- console.log(output) --&gt; %&gt; &lt;% &lt;!-- 递归输出侧边栏目录 tree --&gt; const showTree = (input) =&gt; { &lt;!-- 按 tile ascii 排序 --&gt; input.sort(function(a, b){ var len = a.title.length &gt; b.title.length ? a.title.length : b.title.length; for ( var i = 0; i &lt; len; i++ ) { res = a.title[i].charCodeAt() - b.title[i].charCodeAt(); if ( res ) { return res } } }); &lt;!-- 循环输出 html 结构 --&gt; input.forEach(function(node) { if ( node.children == 0 ) { %&gt; &lt;ul&gt; &lt;li class=&quot;file&lt;%- (is_post() &amp;&amp; node.post._id == page._id) ? ' active' : '' %&gt;&quot;&gt; &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- node.post.path %&gt;&quot;&gt; &lt;i class=&quot;fa fa-file&quot;&gt;&lt;/i&gt; &lt;%- node.title %&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;% } else { %&gt; &lt;ul&gt; &lt;li class=&quot;directory&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;directory&quot;&gt; &lt;i class=&quot;fa fa-folder&quot;&gt;&lt;/i&gt; &lt;%- node.title %&gt; &lt;/a&gt; &lt;%- showTree(node.children) %&gt; &lt;/li&gt; &lt;/ul&gt; &lt;% } }); } showTree(pathToTree(site.posts)) %&gt;&lt;/div&gt; (6) post.ejs12345678&lt;div&gt; &lt;span id=&quot;post-author&quot;&gt;作者: &lt;%- theme.author %&gt;&lt;/span&gt; &lt;span id=&quot;post-date&quot;&gt;&lt;%- date(page.date, &quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;article&quot;&gt; &lt;%- page.content %&gt;&lt;/div&gt; (7)代码高亮使用highlightjs , 下载系统换的主题, 然后放到source的lib 中见主题配置文件 在 『layout.ejs』中，引入它的 css 与 js，引入后，记得让高亮加载 如果代码高亮未成功, 到总配置文件的查看 ,高亮是不是已经设置, 用自己的高亮,就如下设置 12345highlight: enable: false line_number: false auto_detect: false tab_replace: 注意: 修改配置文件后, 重启hexo前, 可执行语句 hexo clean 来清除缓存 (8) 点击事件–main.js引入jquery库, 放在source/lib目录下 然后在layout.ejs中引用jquery (js的函数库), 所以jquery的引用要在js 之前 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111$(document).ready(function () { clickTreeDirectory(); serachTree(); pjaxLoad();});// 点击目录事件function clickTreeDirectory() { // 判断有 active 的话，就递归循环把它的父目录打开 var treeActive = $(\"#tree .active\"); if ( treeActive.length ) { showActiveTree(treeActive, true); } // 点击目录，就触发折叠动画效果 $(document).on(\"click\", \"#tree a[class='directory']\", function (e) { // 用来清空所有绑定的其他事件 event.preventDefault(); var icon = $(this).children(\".fa\"); var iconIsOpen = icon.hasClass(\"fa-folder-open\"); var subTree = $(this).siblings(\"ul\"); icon.removeClass(\"fa-folder-open\").removeClass(\"fa-folder\"); if (iconIsOpen) { if (typeof subTree != \"undefined\") { subTree.slideUp({ duration: 100 }); } icon.addClass(\"fa-folder\"); } else { if (typeof subTree != \"undefined\") { subTree.slideDown({ duration: 100 }); } icon.addClass(\"fa-folder-open\"); } });}// 循环递归展开父节点function showActiveTree(jqNode, isSiblings) { if ( jqNode.attr(\"id\") === \"tree\" ) { return; } if ( jqNode.is(\"ul\") ) { jqNode.css(\"display\", \"block\"); // 这个 isSiblings 是给搜索用的 // true 就显示开同级兄弟节点 // false 就是给搜索用的，值需要展示它自己就好了，不展示兄弟节点 if ( isSiblings ) { jqNode.siblings().css(\"display\", \"block\"); jqNode.siblings(\"a\").css(\"display\", \"inline\"); jqNode.siblings(\"a\").find(\".fa-folder\").removeClass(\"fa-folder\").addClass(\"fa-folder-open\"); } } jqNode.each(function(){ showActiveTree($(this).parent(), isSiblings); }); }// 搜索框输入事件function serachTree() { // 解决搜索大小写问题 jQuery.expr[':'].contains = function (a, i, m) { return jQuery(a).text().toUpperCase().indexOf(m[3].toUpperCase()) &gt;= 0; }; $(\"#search input\").on(\"input\", function(e){ e.preventDefault(); // 获取 inpiut 输入框的内容 var inputContent = e.currentTarget.value; // 没值就收起父目录，但是得把 active 的父目录都展开 if ( inputContent.length === 0 ) { $(\".fa-folder-open\").removeClass(\"fa-folder-open\").addClass(\"fa-folder\"); $(\"#tree ul\").css(\"display\", \"none\"); if ( $(\"#tree .active\").length ) { showActiveTree($(\"#tree .active\"), true); } else { $(\"#tree\").children().css(\"display\", \"block\"); } } // 有值就搜索，并且展开父目录 else { $(\".fa-folder\").removeClass(\"fa-folder\").addClass(\"fa-folder-open\"); $(\"#tree ul\").css(\"display\", \"none\"); var searchResult = $(\"#tree li\").find(\"a:contains('\" + inputContent + \"')\"); if ( searchResult.length ) { showActiveTree(searchResult.parent(), false) } } });}//局部刷新function pjaxLoad(){ $(document).pjax('#tree a', '#content', {fragment:'#content', timeout:8000}); $(document).pjax('#menu a', '#content', {fragment:'#content', timeout:8000}); $(document).pjax('#articleList a', '#content', {fragment:'#content', timeout:8000}); $(document).on({ \"pjax:complete\": function(e) { $(\"pre code\").each(function (i, block){ hljs.highlightBlock(block); }); // 添加 active $(\"#tree .active\").removeClass(\"active\"); e.relatedTarget.parentNode.classList.add(\"active\"); showArticleIndex(); } });} (9)搜索框用于侧边栏目录搜索 在main.js中添加语句 (10) 局部刷新用ajax做局部刷新 , 搜索栏出现结果后, 点击目录, 在正文中局部刷新信息 pjax 可以实现此功能 放入source目录下, 在layout.ejs中引用 (11)主页 index.js效果是全局文章浏览 1234567891011121314151617&lt;div id=&quot;articleList&quot;&gt; &lt;ul&gt; &lt;% site.posts.forEach(function(post){ %&gt; &lt;li class=&quot;article-li&quot;&gt; &lt;span class=&quot;article-date&quot;&gt;&lt;%- date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt; &lt;a class=&quot;article-read&quot; href=&quot;&lt;%- config.root %&gt;&lt;%- post.path %&gt;&quot;&gt; 阅读全文 &lt;/span&gt; &lt;a class=&quot;article-title&quot; href=&quot;&lt;%- config.root %&gt;&lt;%- post.path %&gt;&quot;&gt;&lt;%- post.slug.split(&quot;/&quot;)[post.slug.split(&quot;/&quot;).length-1] %&gt;&lt;/a&gt; &lt;div class=&quot;article-digest&quot;&gt; &lt;%- post.more.replace(/&lt;\\/?.+?\\/?&gt;/g, &quot;&quot;).substring(0, 100) %&gt; ... &lt;/div&gt; &lt;/li&gt; &lt;% }); %&gt; &lt;/ul&gt;&lt;/div&gt; 美化主页样式 ,见main.css 主页 js见main.js (12) 关于是个人信息,直接引入md 在hexo的-post同级目录下,新建about目录,然后新建index.md (13) 手机端自适应在css中设置, 当浏览器窗口小于 800px 时并且处于手机竖屏状态，隐藏侧边栏，留给手机端足够的空间进行文字浏览 四 部署到github静态页面上参考文章 : https://www.cnblogs.com/yyhh/p/11058985.html","link":"/2020/02/13/hexo%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[],"categories":[]}